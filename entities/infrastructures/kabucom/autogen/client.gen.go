// Package autogen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.2 DO NOT EDIT.
package autogen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for ExchangeGetParamsSymbol.
const (
	Audjpy ExchangeGetParamsSymbol = "audjpy"
	Audusd ExchangeGetParamsSymbol = "audusd"
	Cadjpy ExchangeGetParamsSymbol = "cadjpy"
	Chfjpy ExchangeGetParamsSymbol = "chfjpy"
	Eurjpy ExchangeGetParamsSymbol = "eurjpy"
	Eurusd ExchangeGetParamsSymbol = "eurusd"
	Gbpjpy ExchangeGetParamsSymbol = "gbpjpy"
	Gbpusd ExchangeGetParamsSymbol = "gbpusd"
	Nzdjpy ExchangeGetParamsSymbol = "nzdjpy"
	Usdjpy ExchangeGetParamsSymbol = "usdjpy"
	Zarjpy ExchangeGetParamsSymbol = "zarjpy"
)

// Defines values for OrdersGetParamsProduct.
const (
	OrdersGetParamsProductN0 OrdersGetParamsProduct = "0"
	OrdersGetParamsProductN1 OrdersGetParamsProduct = "1"
	OrdersGetParamsProductN2 OrdersGetParamsProduct = "2"
	OrdersGetParamsProductN3 OrdersGetParamsProduct = "3"
	OrdersGetParamsProductN4 OrdersGetParamsProduct = "4"
)

// Defines values for OrdersGetParamsState.
const (
	OrdersGetParamsStateN1 OrdersGetParamsState = "1"
	OrdersGetParamsStateN2 OrdersGetParamsState = "2"
	OrdersGetParamsStateN3 OrdersGetParamsState = "3"
	OrdersGetParamsStateN4 OrdersGetParamsState = "4"
	OrdersGetParamsStateN5 OrdersGetParamsState = "5"
)

// Defines values for OrdersGetParamsSide.
const (
	OrdersGetParamsSideN1 OrdersGetParamsSide = "1"
	OrdersGetParamsSideN2 OrdersGetParamsSide = "2"
)

// Defines values for OrdersGetParamsCashmargin.
const (
	OrdersGetParamsCashmarginN2 OrdersGetParamsCashmargin = "2"
	OrdersGetParamsCashmarginN3 OrdersGetParamsCashmargin = "3"
)

// Defines values for PositionsGetParamsProduct.
const (
	PositionsGetParamsProductN0 PositionsGetParamsProduct = "0"
	PositionsGetParamsProductN1 PositionsGetParamsProduct = "1"
	PositionsGetParamsProductN2 PositionsGetParamsProduct = "2"
	PositionsGetParamsProductN3 PositionsGetParamsProduct = "3"
	PositionsGetParamsProductN4 PositionsGetParamsProduct = "4"
)

// Defines values for PositionsGetParamsSide.
const (
	PositionsGetParamsSideN1 PositionsGetParamsSide = "1"
	PositionsGetParamsSideN2 PositionsGetParamsSide = "2"
)

// Defines values for RankingGetParamsType.
const (
	N1  RankingGetParamsType = "1"
	N10 RankingGetParamsType = "10"
	N11 RankingGetParamsType = "11"
	N12 RankingGetParamsType = "12"
	N13 RankingGetParamsType = "13"
	N14 RankingGetParamsType = "14"
	N15 RankingGetParamsType = "15"
	N2  RankingGetParamsType = "2"
	N3  RankingGetParamsType = "3"
	N4  RankingGetParamsType = "4"
	N5  RankingGetParamsType = "5"
	N6  RankingGetParamsType = "6"
	N7  RankingGetParamsType = "7"
	N8  RankingGetParamsType = "8"
	N9  RankingGetParamsType = "9"
)

// Defines values for RankingGetParamsExchangeDivision.
const (
	ALL RankingGetParamsExchangeDivision = "ALL"
	FK  RankingGetParamsExchangeDivision = "FK"
	M   RankingGetParamsExchangeDivision = "M"
	S   RankingGetParamsExchangeDivision = "S"
	T   RankingGetParamsExchangeDivision = "T"
	TG  RankingGetParamsExchangeDivision = "TG"
	TP  RankingGetParamsExchangeDivision = "TP"
	TS  RankingGetParamsExchangeDivision = "TS"
)

// ApiSoftLimitResponse defines model for ApiSoftLimitResponse.
type ApiSoftLimitResponse struct {
	// Future 先物のワンショット上限<br>※単位は枚
	Future *float64 `json:"Future,omitempty"`

	// FutureMini 先物ミニのワンショット上限<br>※単位は枚
	FutureMini *float64 `json:"FutureMini,omitempty"`

	// KabuSVersion kabuステーションのバージョン
	KabuSVersion *string `json:"KabuSVersion,omitempty"`

	// Margin 信用のワンショット上限<br>※単位は万円
	Margin *float64 `json:"Margin,omitempty"`

	// Option オプションのワンショット上限<br>※単位は枚
	Option *float64 `json:"Option,omitempty"`

	// Stock 現物のワンショット上限<br>※単位は万円
	Stock *float64 `json:"Stock,omitempty"`
}

// BoardSuccess 下記にあるBIDとASKとは、トレーダー目線から見た場合の値であるため、BidPrice=Sell1のPrice、AskPrice=Buy1のPriceという数値となります。
type BoardSuccess struct {
	// AskPrice 最良買気配値段 ※①<br>※株式・先物・オプション銘柄の場合のみ
	AskPrice *float64 `json:"AskPrice,omitempty"`

	// AskQty 最良買気配数量 ※①<br>※株式・先物・オプション銘柄の場合のみ
	AskQty *float64 `json:"AskQty,omitempty"`

	// AskSign 最良買気配フラグ ※①<br>※株式・先物・オプション銘柄の場合のみ
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0000</td>
	//           <td>事象なし</td>
	//       </tr>
	//       <tr>
	//           <td>0101</td>
	//           <td>一般気配</td>
	//       </tr>
	//       <tr>
	//           <td>0102</td>
	//           <td>特別気配</td>
	//       </tr>
	//       <tr>
	//           <td>0103</td>
	//           <td>注意気配</td>
	//       </tr>
	//       <tr>
	//           <td>0107</td>
	//           <td>寄前気配</td>
	//       </tr>
	//       <tr>
	//           <td>0108</td>
	//           <td>停止前特別気配</td>
	//       </tr>
	//       <tr>
	//           <td>0109</td>
	//           <td>引け後気配</td>
	//       </tr>
	//       <tr>
	//           <td>0116</td>
	//           <td>寄前気配約定成立ポイントなし</td>
	//       </tr>
	//       <tr>
	//           <td>0117</td>
	//           <td>寄前気配約定成立ポイントあり</td>
	//       </tr>
	//       <tr>
	//           <td>0118</td>
	//           <td>連続約定気配</td>
	//       </tr>
	//       <tr>
	//           <td>0119</td>
	//           <td>停止前の連続約定気配</td>
	//       </tr>
	//       <tr>
	//           <td>0120</td>
	//           <td>買い上がり売り下がり中</td>
	//       </tr>
	//   </tbody>
	// </table>
	AskSign *string `json:"AskSign,omitempty"`

	// AskTime 最良買気配時刻 ※①<br>※株式銘柄の場合のみ
	AskTime *time.Time `json:"AskTime,omitempty"`

	// BidPrice 最良売気配値段 ※①<br>※株式・先物・オプション銘柄の場合のみ
	BidPrice *float64 `json:"BidPrice,omitempty"`

	// BidQty 最良売気配数量 ※①<br>※株式・先物・オプション銘柄の場合のみ
	BidQty *float64 `json:"BidQty,omitempty"`

	// BidSign 最良売気配フラグ ※①<br>※株式・先物・オプション銘柄の場合のみ
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0000</td>
	//           <td>事象なし</td>
	//       </tr>
	//       <tr>
	//           <td>0101</td>
	//           <td>一般気配</td>
	//       </tr>
	//       <tr>
	//           <td>0102</td>
	//           <td>特別気配</td>
	//       </tr>
	//       <tr>
	//           <td>0103</td>
	//           <td>注意気配</td>
	//       </tr>
	//       <tr>
	//           <td>0107</td>
	//           <td>寄前気配</td>
	//       </tr>
	//       <tr>
	//           <td>0108</td>
	//           <td>停止前特別気配</td>
	//       </tr>
	//       <tr>
	//           <td>0109</td>
	//           <td>引け後気配</td>
	//       </tr>
	//       <tr>
	//           <td>0116</td>
	//           <td>寄前気配約定成立ポイントなし</td>
	//       </tr>
	//       <tr>
	//           <td>0117</td>
	//           <td>寄前気配約定成立ポイントあり</td>
	//       </tr>
	//       <tr>
	//           <td>0118</td>
	//           <td>連続約定気配</td>
	//       </tr>
	//       <tr>
	//           <td>0119</td>
	//           <td>停止前の連続約定気配</td>
	//       </tr>
	//       <tr>
	//           <td>0120</td>
	//           <td>買い上がり売り下がり中</td>
	//       </tr>
	//   </tbody>
	// </table>
	BidSign *string `json:"BidSign,omitempty"`

	// BidTime 最良売気配時刻 ※①<br>※株式銘柄の場合のみ
	BidTime *time.Time `json:"BidTime,omitempty"`

	// Buy1 買気配数量1本目
	Buy1 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`

		// Sign 気配フラグ<br>※株式・先物・オプション銘柄の場合のみ
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>0000</td>
		//           <td>事象なし</td>
		//       </tr>
		//       <tr>
		//           <td>0101</td>
		//           <td>一般気配</td>
		//       </tr>
		//       <tr>
		//           <td>0102</td>
		//           <td>特別気配</td>
		//       </tr>
		//       <tr>
		//           <td>0103</td>
		//           <td>注意気配</td>
		//       </tr>
		//       <tr>
		//           <td>0107</td>
		//           <td>寄前気配</td>
		//       </tr>
		//       <tr>
		//           <td>0108</td>
		//           <td>停止前特別気配</td>
		//       </tr>
		//       <tr>
		//           <td>0109</td>
		//           <td>引け後気配</td>
		//       </tr>
		//       <tr>
		//           <td>0116</td>
		//           <td>寄前気配約定成立ポイントなし</td>
		//       </tr>
		//       <tr>
		//           <td>0117</td>
		//           <td>寄前気配約定成立ポイントあり</td>
		//       </tr>
		//       <tr>
		//           <td>0118</td>
		//           <td>連続約定気配</td>
		//       </tr>
		//       <tr>
		//           <td>0119</td>
		//           <td>停止前の連続約定気配</td>
		//       </tr>
		//       <tr>
		//           <td>0120</td>
		//           <td>買い上がり売り下がり中</td>
		//       </tr>
		//   </tbody>
		// </table>
		Sign *string `json:"Sign,omitempty"`

		// Time 時刻<br>※株式銘柄の場合のみ
		Time *time.Time `json:"Time,omitempty"`
	} `json:"Buy1,omitempty"`

	// Buy10 買気配数量10本目
	Buy10 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Buy10,omitempty"`

	// Buy2 買気配数量2本目
	Buy2 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Buy2,omitempty"`

	// Buy3 買気配数量3本目
	Buy3 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Buy3,omitempty"`

	// Buy4 買気配数量4本目
	Buy4 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Buy4,omitempty"`

	// Buy5 買気配数量5本目
	Buy5 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Buy5,omitempty"`

	// Buy6 買気配数量6本目
	Buy6 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Buy6,omitempty"`

	// Buy7 買気配数量7本目
	Buy7 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Buy7,omitempty"`

	// Buy8 買気配数量8本目
	Buy8 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Buy8,omitempty"`

	// Buy9 買気配数量9本目
	Buy9 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Buy9,omitempty"`

	// CalcPrice 計算用現値
	CalcPrice *float64 `json:"CalcPrice,omitempty"`

	// ChangePreviousClose 前日比
	ChangePreviousClose *float64 `json:"ChangePreviousClose,omitempty"`

	// ChangePreviousClosePer 騰落率
	ChangePreviousClosePer *float64 `json:"ChangePreviousClosePer,omitempty"`

	// ClearingPrice 清算値<br>※先物銘柄の場合のみ
	ClearingPrice *float64 `json:"ClearingPrice,omitempty"`

	// CurrentPrice 現値
	CurrentPrice *float64 `json:"CurrentPrice,omitempty"`

	// CurrentPriceChangeStatus 現値前値比較
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0000</td>
	//           <td>事象なし</td>
	//       </tr>
	//       <tr>
	//           <td>0056</td>
	//           <td>変わらず</td>
	//       </tr>
	//       <tr>
	//           <td>0057</td>
	//           <td>UP</td>
	//       </tr>
	//       <tr>
	//           <td>0058</td>
	//           <td>DOWN</td>
	//       </tr>
	//       <tr>
	//           <td>0059</td>
	//           <td>中断板寄り後の初値</td>
	//       </tr>
	//       <tr>
	//           <td>0060</td>
	//           <td>ザラバ引け</td>
	//       </tr>
	//       <tr>
	//           <td>0061</td>
	//           <td>板寄り引け</td>
	//       </tr>
	//       <tr>
	//           <td>0062</td>
	//           <td>中断引け</td>
	//       </tr>
	//       <tr>
	//           <td>0063</td>
	//           <td>ダウン引け</td>
	//       </tr>
	//       <tr>
	//           <td>0064</td>
	//           <td>逆転終値</td>
	//       </tr>
	//       <tr>
	//           <td>0066</td>
	//           <td>特別気配引け</td>
	//       </tr>
	//       <tr>
	//           <td>0067</td>
	//           <td>一時留保引け</td>
	//       </tr>
	//       <tr>
	//           <td>0068</td>
	//           <td>売買停止引け</td>
	//       </tr>
	//       <tr>
	//           <td>0069</td>
	//           <td>サーキットブレーカ引け</td>
	//       </tr>
	//       <tr>
	//           <td>0431</td>
	//           <td>ダイナミックサーキットブレーカ引け</td>
	//       </tr>
	//   </tbody>
	// </table>
	CurrentPriceChangeStatus *string `json:"CurrentPriceChangeStatus,omitempty"`

	// CurrentPriceStatus 現値ステータス
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>現値</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>不連続歩み</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>板寄せ</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>システム障害</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>中断</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>売買停止</td>
	//       </tr>
	//       <tr>
	//           <td>7</td>
	//           <td>売買停止・システム停止解除</td>
	//       </tr>
	//       <tr>
	//           <td>8</td>
	//           <td>終値</td>
	//       </tr>
	//       <tr>
	//           <td>9</td>
	//           <td>システム停止</td>
	//       </tr>
	//       <tr>
	//           <td>10</td>
	//           <td>概算値</td>
	//       </tr>
	//       <tr>
	//           <td>11</td>
	//           <td>参考値</td>
	//       </tr>
	//       <tr>
	//           <td>12</td>
	//           <td>サーキットブレイク実施中</td>
	//       </tr>
	//       <tr>
	//           <td>13</td>
	//           <td>システム障害解除</td>
	//       </tr>
	//       <tr>
	//           <td>14</td>
	//           <td>サーキットブレイク解除</td>
	//       </tr>
	//       <tr>
	//           <td>15</td>
	//           <td>中断解除</td>
	//       </tr>
	//       <tr>
	//           <td>16</td>
	//           <td>一時留保中</td>
	//       </tr>
	//       <tr>
	//           <td>17</td>
	//           <td>一時留保解除</td>
	//       </tr>
	//       <tr>
	//           <td>18</td>
	//           <td>ファイル障害</td>
	//       </tr>
	//       <tr>
	//           <td>19</td>
	//           <td>ファイル障害解除</td>
	//       </tr>
	//       <tr>
	//           <td>20</td>
	//           <td>Spread/Strategy</td>
	//       </tr>
	//       <tr>
	//           <td>21</td>
	//           <td>ダイナミックサーキットブレイク発動</td>
	//       </tr>
	//       <tr>
	//           <td>22</td>
	//           <td>ダイナミックサーキットブレイク解除</td>
	//       </tr>
	//       <tr>
	//           <td>23</td>
	//           <td>板寄せ約定</td>
	//       </tr>
	//   </tbody>
	// </table>
	CurrentPriceStatus *int32 `json:"CurrentPriceStatus,omitempty"`

	// CurrentPriceTime 現値時刻
	CurrentPriceTime *time.Time `json:"CurrentPriceTime,omitempty"`

	// Delta デルタ<br>※オプション銘柄かつ日通しの場合のみ
	Delta *float64 `json:"Delta,omitempty"`

	// Exchange 市場コード<br>※株式・先物・オプション銘柄の場合のみ
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>東証</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>名証</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>福証</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>札証</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>日通し</td>
	//       </tr>
	//       <tr>
	//           <td>23</td>
	//           <td>日中</td>
	//       </tr>
	//       <tr>
	//           <td>24</td>
	//           <td>夜間</td>
	//       </tr>
	//   </tbody>
	// </table>
	Exchange *int32 `json:"Exchange,omitempty"`

	// ExchangeName 市場名称<br>※株式・先物・オプション銘柄の場合のみ
	ExchangeName *string `json:"ExchangeName,omitempty"`

	// Gamma ガンマ<br>※オプション銘柄かつ日通しの場合のみ
	Gamma *float64 `json:"Gamma,omitempty"`

	// HighPrice 高値
	HighPrice *float64 `json:"HighPrice,omitempty"`

	// HighPriceTime 高値時刻
	HighPriceTime *time.Time `json:"HighPriceTime,omitempty"`

	// IV インプライド・ボラティリティ<br>※オプション銘柄かつ日通しの場合のみ
	IV *float64 `json:"IV,omitempty"`

	// LowPrice 安値
	LowPrice *float64 `json:"LowPrice,omitempty"`

	// LowPriceTime 安値時刻
	LowPriceTime *time.Time `json:"LowPriceTime,omitempty"`

	// MarketOrderBuyQty 買成行数量<br>※株式銘柄の場合のみ
	MarketOrderBuyQty *float64 `json:"MarketOrderBuyQty,omitempty"`

	// MarketOrderSellQty 売成行数量<br>※株式銘柄の場合のみ
	MarketOrderSellQty *float64 `json:"MarketOrderSellQty,omitempty"`

	// OpeningPrice 始値
	OpeningPrice *float64 `json:"OpeningPrice,omitempty"`

	// OpeningPriceTime 始値時刻
	OpeningPriceTime *time.Time `json:"OpeningPriceTime,omitempty"`

	// OverSellQty OVER気配数量<br>※株式銘柄の場合のみ
	OverSellQty *float64 `json:"OverSellQty,omitempty"`

	// PreviousClose 前日終値
	PreviousClose *float64 `json:"PreviousClose,omitempty"`

	// PreviousCloseTime 前日終値日付
	PreviousCloseTime *time.Time `json:"PreviousCloseTime,omitempty"`

	// SecurityType 銘柄種別
	// <table>
	//   <thead>
	//     <tr>
	//       <th>定義値</th>
	//       <th>説明</th>
	//     </tr>
	//   </thead>
	//   <tbody>
	//     <tr>
	//       <td>0</td>
	//       <td>指数</td>
	//     </tr>
	//     <tr>
	//       <td>1</td>
	//       <td>現物</td>
	//     </tr>
	//     <tr>
	//       <td>101</td>
	//       <td>日経225先物</td>
	//     </tr>
	//     <tr>
	//       <td>103</td>
	//       <td>日経225OP</td>
	//     </tr>
	//     <tr>
	//       <td>107</td>
	//       <td>TOPIX先物</td>
	//     </tr>
	//     <tr>
	//       <td>121</td>
	//       <td>JPX400先物</td>
	//     </tr>
	//     <tr>
	//       <td>144</td>
	//       <td>NYダウ</td>
	//     </tr>
	//     <tr>
	//       <td>145</td>
	//       <td>日経平均VI</td>
	//     </tr>
	//     <tr>
	//       <td>154</td>
	//       <td>東証マザーズ指数先物</td>
	//     </tr>
	//     <tr>
	//       <td>155</td>
	//       <td>TOPIX_REIT</td>
	//     </tr>
	//     <tr>
	//       <td>171</td>
	//       <td>TOPIX CORE30</td>
	//     </tr>
	//     <tr>
	//       <td>901</td>
	//       <td>日経平均225ミニ先物</td>
	//     </tr>
	//     <tr>
	//       <td>907</td>
	//       <td>TOPIXミニ先物</td>
	//     </tr>
	//   </tbody>
	// </table>
	SecurityType *int32 `json:"SecurityType,omitempty"`

	// Sell1 売気配数量1本目
	Sell1 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`

		// Sign 気配フラグ<br>※株式・先物・オプション銘柄の場合のみ
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>0000</td>
		//           <td>事象なし</td>
		//       </tr>
		//       <tr>
		//           <td>0101</td>
		//           <td>一般気配</td>
		//       </tr>
		//       <tr>
		//           <td>0102</td>
		//           <td>特別気配</td>
		//       </tr>
		//       <tr>
		//           <td>0103</td>
		//           <td>注意気配</td>
		//       </tr>
		//       <tr>
		//           <td>0107</td>
		//           <td>寄前気配</td>
		//       </tr>
		//       <tr>
		//           <td>0108</td>
		//           <td>停止前特別気配</td>
		//       </tr>
		//       <tr>
		//           <td>0109</td>
		//           <td>引け後気配</td>
		//       </tr>
		//       <tr>
		//           <td>0116</td>
		//           <td>寄前気配約定成立ポイントなし</td>
		//       </tr>
		//       <tr>
		//           <td>0117</td>
		//           <td>寄前気配約定成立ポイントあり</td>
		//       </tr>
		//       <tr>
		//           <td>0118</td>
		//           <td>連続約定気配</td>
		//       </tr>
		//       <tr>
		//           <td>0119</td>
		//           <td>停止前の連続約定気配</td>
		//       </tr>
		//       <tr>
		//           <td>0120</td>
		//           <td>買い上がり売り下がり中</td>
		//       </tr>
		//   </tbody>
		// </table>
		Sign *string `json:"Sign,omitempty"`

		// Time 時刻<br>※株式銘柄の場合のみ
		Time *time.Time `json:"Time,omitempty"`
	} `json:"Sell1,omitempty"`

	// Sell10 売気配数量10本目
	Sell10 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Sell10,omitempty"`

	// Sell2 売気配数量2本目
	Sell2 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Sell2,omitempty"`

	// Sell3 売気配数量3本目
	Sell3 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Sell3,omitempty"`

	// Sell4 売気配数量4本目
	Sell4 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Sell4,omitempty"`

	// Sell5 売気配数量5本目
	Sell5 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Sell5,omitempty"`

	// Sell6 売気配数量6本目
	Sell6 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Sell6,omitempty"`

	// Sell7 売気配数量7本目
	Sell7 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Sell7,omitempty"`

	// Sell8 売気配数量8本目
	Sell8 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Sell8,omitempty"`

	// Sell9 売気配数量9本目
	Sell9 *struct {
		// Price 値段<br>※株式・先物・オプション銘柄の場合のみ
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量<br>※株式・先物・オプション銘柄の場合のみ
		Qty *float64 `json:"Qty,omitempty"`
	} `json:"Sell9,omitempty"`

	// Symbol 銘柄コード
	Symbol *string `json:"Symbol,omitempty"`

	// SymbolName 銘柄名
	SymbolName *string `json:"SymbolName,omitempty"`

	// Theta セータ<br>※オプション銘柄かつ日通しの場合のみ
	Theta *float64 `json:"Theta,omitempty"`

	// TotalMarketValue 時価総額<br>※株式銘柄の場合のみ
	TotalMarketValue *float64 `json:"TotalMarketValue,omitempty"`

	// TradingValue 売買代金<br>※株式・先物・オプション銘柄の場合のみ
	TradingValue *float64 `json:"TradingValue,omitempty"`

	// TradingVolume 売買高<br>※株式・先物・オプション銘柄の場合のみ
	TradingVolume *float64 `json:"TradingVolume,omitempty"`

	// TradingVolumeTime 売買高時刻<br>※株式・先物・オプション銘柄の場合のみ
	TradingVolumeTime *time.Time `json:"TradingVolumeTime,omitempty"`

	// UnderBuyQty UNDER気配数量<br>※株式銘柄の場合のみ
	UnderBuyQty *float64 `json:"UnderBuyQty,omitempty"`

	// VWAP 売買高加重平均価格（VWAP）<br>※株式・先物・オプション銘柄の場合のみ
	VWAP *float64 `json:"VWAP,omitempty"`

	// Vega ベガ<br>※オプション銘柄かつ日通しの場合のみ
	Vega *float64 `json:"Vega,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Code エラーコード
	Code *int32 `json:"Code,omitempty"`

	// Message [エラーメッセージ](../ptal/error.html#message)
	Message *string `json:"Message,omitempty"`
}

// ExchangeResponse defines model for ExchangeResponse.
type ExchangeResponse struct {
	// AskPrice ASK
	AskPrice *float64 `json:"AskPrice,omitempty"`

	// BidPrice BID
	BidPrice *float64 `json:"BidPrice,omitempty"`

	// Change 前日比
	Change *float64 `json:"Change,omitempty"`

	// Spread SP
	Spread *float64 `json:"Spread,omitempty"`

	// Symbol 通貨
	Symbol *string `json:"Symbol,omitempty"`

	// Time 時刻 <br>※HH:mm:ss形式
	Time *string `json:"Time,omitempty"`
}

// MarginPremiumResponse defines model for MarginPremiumResponse.
type MarginPremiumResponse struct {
	// DayTrade 一般信用（デイトレ）
	DayTrade *struct {
		// LowerMarginPremium 下限プレミアム料<br>
		// ※プレミアム料がない場合は、nullを返します。
		LowerMarginPremium *float64 `json:"LowerMarginPremium,omitempty"`

		// MarginPremium 確定プレミアム料<br>
		// ※入札銘柄の場合、入札受付中は随時更新します。受付時間外は、確定したプレミアム料を返します。<br>
		// ※非入札銘柄の場合、常に固定値を返します。<br>
		// ※信用取引不可の場合、nullを返します。<br>
		// ※19:30~翌営業日のプレミアム料になります。
		MarginPremium *float64 `json:"MarginPremium,omitempty"`

		// MarginPremiumType プレミアム料入力区分
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>null</td>
		//           <td>一般信用（デイトレ）非対応銘柄</td>
		//       </tr>
		//       <tr>
		//           <td>0</td>
		//           <td>プレミアム料がない銘柄</td>
		//       </tr>
		//       <tr>
		//           <td>1</td>
		//           <td>プレミアム料が固定の銘柄</td>
		//       </tr>
		//       <tr>
		//           <td>2</td>
		//           <td>プレミアム料が入札で決定する銘柄</td>
		//       </tr>
		//   </tbody>
		// </table>
		MarginPremiumType *int32 `json:"MarginPremiumType,omitempty"`

		// TickMarginPremium プレミアム料刻値<br>
		// ※入札可能銘柄以外は、nullを返します。
		TickMarginPremium *float64 `json:"TickMarginPremium,omitempty"`

		// UpperMarginPremium 上限プレミアム料<br>
		// ※プレミアム料がない場合は、nullを返します。
		UpperMarginPremium *float64 `json:"UpperMarginPremium,omitempty"`
	} `json:"DayTrade,omitempty"`

	// GeneralMargin 一般信用（長期）
	GeneralMargin *struct {
		// LowerMarginPremium 下限プレミアム料<br>
		// ※プレミアム料がない場合は、nullを返します。
		LowerMarginPremium *float64 `json:"LowerMarginPremium,omitempty"`

		// MarginPremium 確定プレミアム料<br>
		// ※入札銘柄の場合、入札受付中は随時更新します。受付時間外は、確定したプレミアム料を返します。<br>
		// ※非入札銘柄の場合、常に固定値を返します。<br>
		// ※信用取引不可の場合、nullを返します。<br>
		// ※19:30~翌営業日のプレミアム料になります。
		MarginPremium *float64 `json:"MarginPremium,omitempty"`

		// MarginPremiumType プレミアム料入力区分
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>null</td>
		//           <td>一般信用（長期）非対応銘柄</td>
		//       </tr>
		//       <tr>
		//           <td>0</td>
		//           <td>プレミアム料がない銘柄</td>
		//       </tr>
		//       <tr>
		//           <td>1</td>
		//           <td>プレミアム料が固定の銘柄</td>
		//       </tr>
		//       <tr>
		//           <td>2</td>
		//           <td>プレミアム料が入札で決定する銘柄</td>
		//       </tr>
		//   </tbody>
		// </table>
		MarginPremiumType *int32 `json:"MarginPremiumType,omitempty"`

		// TickMarginPremium プレミアム料刻値<br>
		// ※入札可能銘柄以外は、nullを返します。
		TickMarginPremium *float64 `json:"TickMarginPremium,omitempty"`

		// UpperMarginPremium 上限プレミアム料<br>
		// ※プレミアム料がない場合は、nullを返します。
		UpperMarginPremium *float64 `json:"UpperMarginPremium,omitempty"`
	} `json:"GeneralMargin,omitempty"`

	// Symbol 銘柄コード
	Symbol *string `json:"Symbol,omitempty"`
}

// OrderSuccess defines model for OrderSuccess.
type OrderSuccess struct {
	// OrderId 受付注文番号
	OrderId *string `json:"OrderId,omitempty"`

	// Result 結果コード<br>0が成功。それ以外はエラーコード。
	Result *int32 `json:"Result,omitempty"`
}

// OrdersSuccess defines model for OrdersSuccess.
type OrdersSuccess struct {
	// AccountType 口座種別
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>2</td>
	//           <td>一般</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>特定</td>
	//       </tr>
	//       <tr>
	//           <td>12</td>
	//           <td>法人</td>
	//       </tr>
	//   </tbody>
	// </table>
	AccountType *int32 `json:"AccountType,omitempty"`

	// CashMargin 取引区分
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>2</td>
	//           <td>新規</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>返済</td>
	//       </tr>
	//   </tbody>
	// </table>
	CashMargin *int32 `json:"CashMargin,omitempty"`

	// CumQty 約定数量
	CumQty *float64 `json:"CumQty,omitempty"`

	// DelivType 受渡区分
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>自動振替</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>お預り金</td>
	//       </tr>
	//   </tbody>
	// </table>
	DelivType *int32 `json:"DelivType,omitempty"`

	// Details 注文詳細
	Details *[]struct {
		// Commission 手数料<br>※注文詳細の明細種別が約定（RecType=8)の場合に設定。
		Commission *float64 `json:"Commission,omitempty"`

		// CommissionTax 手数料消費税<br>※明細種別は約定（RecType=8）の場合にのみ表示されます。
		CommissionTax *float64 `json:"CommissionTax,omitempty"`

		// DelivDay 受渡日
		DelivDay *int32 `json:"DelivDay,omitempty"`

		// ExchangeID 取引所番号
		ExchangeID *string `json:"ExchangeID,omitempty"`

		// ExecutionDay 約定日時
		ExecutionDay *time.Time `json:"ExecutionDay,omitempty"`

		// ExecutionID 約定番号
		ExecutionID *string `json:"ExecutionID,omitempty"`

		// ID 注文詳細番号
		ID *string `json:"ID,omitempty"`

		// OrdType 執行条件
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>1</td>
		//           <td>ザラバ</td>
		//       </tr>
		//       <tr>
		//           <td>2</td>
		//           <td>寄り</td>
		//       </tr>
		//       <tr>
		//           <td>3</td>
		//           <td>引け</td>
		//       </tr>
		//       <tr>
		//           <td>4</td>
		//           <td>不成</td>
		//       </tr>
		//       <tr>
		//           <td>5</td>
		//           <td>対当指値</td>
		//       </tr>
		//       <tr>
		//           <td>6</td>
		//           <td>IOC</td>
		//       </tr>
		//   </tbody>
		// </table>
		OrdType *int32 `json:"OrdType,omitempty"`

		// Price 値段
		Price *float64 `json:"Price,omitempty"`

		// Qty 数量
		Qty *float64 `json:"Qty,omitempty"`

		// RecType 明細種別
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>1</td>
		//           <td>受付</td>
		//       </tr>
		//       <tr>
		//           <td>2</td>
		//           <td>繰越</td>
		//       </tr>
		//       <tr>
		//           <td>3</td>
		//           <td>期限切れ</td>
		//       </tr>
		//       <tr>
		//           <td>4</td>
		//           <td>発注</td>
		//       </tr>
		//       <tr>
		//           <td>5</td>
		//           <td>訂正</td>
		//       </tr>
		//       <tr>
		//           <td>6</td>
		//           <td>取消</td>
		//       </tr>
		//       <tr>
		//           <td>7</td>
		//           <td>失効</td>
		//       </tr>
		//       <tr>
		//           <td>8</td>
		//           <td>約定</td>
		//       </tr>
		//   </tbody>
		// </table>
		RecType *int32 `json:"RecType,omitempty"`

		// SeqNum ※注文明細レコードの生成順序です。<br>※通番であるとは限りませんが、大小による順序は保たれています。
		SeqNum *int32 `json:"SeqNum,omitempty"`

		// State 状態
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>1</td>
		//           <td>待機（発注待機）</td>
		//       </tr>
		//       <tr>
		//           <td>2</td>
		//           <td>処理中（発注送信中・訂正送信中・取消送信中）</td>
		//       </tr>
		//       <tr>
		//           <td>3</td>
		//           <td>処理済（発注済・訂正済・取消済・全約定・期限切れ）</td>
		//       </tr>
		//       <tr>
		//           <td>4</td>
		//           <td>エラー</td>
		//       </tr>
		//       <tr>
		//           <td>5</td>
		//           <td>削除済み</td>
		//       </tr>
		//   </tbody>
		// </table>
		State *int32 `json:"State,omitempty"`

		// TransactTime 処理時刻
		TransactTime *string `json:"TransactTime,omitempty"`
	} `json:"Details,omitempty"`

	// Exchange 市場コード
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>東証</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>名証</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>福証</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>札証</td>
	//       </tr>
	//       <tr>
	//           <td>9</td>
	//           <td>SOR</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>日通し</td>
	//       </tr>
	//       <tr>
	//           <td>23</td>
	//           <td>日中</td>
	//       </tr>
	//       <tr>
	//           <td>24</td>
	//           <td>夜間</td>
	//       </tr>
	//   </tbody>
	// </table>
	Exchange *int32 `json:"Exchange,omitempty"`

	// ExchangeName 市場名
	ExchangeName *string `json:"ExchangeName,omitempty"`

	// ExpireDay 注文有効期限<br>yyyyMMdd形式
	ExpireDay *int32 `json:"ExpireDay,omitempty"`

	// ID 注文番号
	ID *string `json:"ID,omitempty"`

	// MarginPremium プレミアム料<br>
	// ※（注文中数量＋約定済数量）×１株あたりプレミアム料として計算されます。<br>
	// ※信用を注文した際に表示されます。<br>
	// ※制度信用売/買、一般（長期）買、一般（デイトレ）買の場合は、Noneと返されます。<br>
	// 一般（長期）売、一般（デイトレ）売の場合は、プレミアム料=0の場合、0（ゼロ）と返されます。
	MarginPremium *float64 `json:"MarginPremium,omitempty"`

	// MarginTradeType 信用取引区分<br>
	// ※信用を注文した際に表示されます。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>制度信用</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>一般信用（長期）</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>一般信用（デイトレ）</td>
	//       </tr>
	//   </tbody>
	// </table>
	MarginTradeType *int32 `json:"MarginTradeType,omitempty"`

	// OrdType 執行条件
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>ザラバ</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>寄り</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>引け</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>不成</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>対当指値</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>IOC</td>
	//       </tr>
	//   </tbody>
	// </table>
	OrdType *int32 `json:"OrdType,omitempty"`

	// OrderQty 発注数量<br>
	// ※注文期限切れと失効の場合、OrderQtyはゼロになりません。<br>
	// ※期限切れと失効の確認方法としては、DetailsのRecType（3: 期限切れ、7: 失効）にてご確認ください。
	OrderQty *float64 `json:"OrderQty,omitempty"`

	// OrderState 注文状態
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>待機（発注待機）</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>処理中（発注送信中）</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>処理済（発注済・訂正済）</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>訂正取消送信中</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>終了（発注エラー・取消済・全約定・失効・期限切れ）</td>
	//       </tr>
	//   </tbody>
	// </table>
	OrderState *int32 `json:"OrderState,omitempty"`

	// Price 値段
	Price *float64 `json:"Price,omitempty"`

	// RecvTime 受注日時
	RecvTime *string `json:"RecvTime,omitempty"`

	// Side 売買区分
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>売</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>買</td>
	//       </tr>
	//   </tbody>
	// </table>
	Side *string `json:"Side,omitempty"`

	// State 状態
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>待機（発注待機）</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>処理中（発注送信中）</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>処理済（発注済・訂正済）</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>訂正取消送信中</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>終了（発注エラー・取消済・全約定・失効・期限切れ）</td>
	//       </tr>
	//   </tbody>
	// </table>
	State *int32 `json:"State,omitempty"`

	// Symbol 銘柄コード
	Symbol *string `json:"Symbol,omitempty"`

	// SymbolName 銘柄名
	SymbolName *string `json:"SymbolName,omitempty"`

	// TimeInForce 有効期間条件<br>※先物・オプション銘柄の場合のみ
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>FAS</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>FAK</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>FOK</td>
	//       </tr>
	//   </tbody>
	// </table>
	TimeInForce *int32 `json:"TimeInForce,omitempty"`
}

// Positions defines model for Positions.
type Positions struct {
	// HoldID 返済建玉ID
	HoldID *string `json:"HoldID,omitempty"`

	// Qty 返済建玉数量
	Qty *int32 `json:"Qty,omitempty"`
}

// PositionsDeriv defines model for PositionsDeriv.
type PositionsDeriv struct {
	// HoldID 返済建玉ID
	HoldID *string `json:"HoldID,omitempty"`

	// Qty 返済建玉数量
	Qty *int32 `json:"Qty,omitempty"`
}

// PositionsSuccess defines model for PositionsSuccess.
type PositionsSuccess struct {
	// AccountType 口座種別
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>2</td>
	//           <td>一般</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>特定</td>
	//       </tr>
	//       <tr>
	//           <td>12</td>
	//           <td>法人</td>
	//       </tr>
	//   </tbody>
	// </table>
	AccountType *int32 `json:"AccountType,omitempty"`

	// Commission 手数料<br>※信用・先物・オプションの場合のみ
	Commission *float64 `json:"Commission,omitempty"`

	// CommissionTax 手数料消費税<br>※信用・先物・オプションの場合のみ
	CommissionTax *float64 `json:"CommissionTax,omitempty"`

	// CurrentPrice 現在値<br>追加情報出力フラグ：falseの場合、null
	CurrentPrice *float64 `json:"CurrentPrice,omitempty"`

	// Exchange 市場コード
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>東証</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>名証</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>福証</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>札証</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>日通し</td>
	//       </tr>
	//       <tr>
	//           <td>23</td>
	//           <td>日中</td>
	//       </tr>
	//       <tr>
	//           <td>24</td>
	//           <td>夜間</td>
	//       </tr>
	//   </tbody>
	// </table>
	Exchange *int32 `json:"Exchange,omitempty"`

	// ExchangeName 市場名
	ExchangeName *string `json:"ExchangeName,omitempty"`

	// ExecutionDay 約定日（建玉日）<br>※信用・先物・オプションの場合のみ<br>※現物取引では、nullが返ります。
	ExecutionDay *int32 `json:"ExecutionDay,omitempty"`

	// ExecutionID 約定番号<br>※現物取引では、nullが返ります。
	ExecutionID *string `json:"ExecutionID,omitempty"`

	// Expenses 諸経費<br>※信用・先物・オプションの場合のみ
	Expenses *float64 `json:"Expenses,omitempty"`

	// ExpireDay 返済期日<br>※信用・先物・オプションの場合のみ
	ExpireDay *int32 `json:"ExpireDay,omitempty"`

	// HoldQty 拘束数量（返済のために拘束されている数量）
	HoldQty *float64 `json:"HoldQty,omitempty"`

	// LeavesQty 残数量（保有数量）
	LeavesQty *float64 `json:"LeavesQty,omitempty"`

	// MarginTradeType 信用取引区分<br>※信用の場合のみ
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>制度信用</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>一般信用（長期）</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>一般信用（デイトレ）</td>
	//       </tr>
	//   </tbody>
	// </table>
	MarginTradeType *int32 `json:"MarginTradeType,omitempty"`

	// Price 値段
	Price *float64 `json:"Price,omitempty"`

	// ProfitLoss 評価損益額<br>追加情報出力フラグ：falseの場合、null
	ProfitLoss *float64 `json:"ProfitLoss,omitempty"`

	// ProfitLossRate 評価損益率<br>追加情報出力フラグ：falseの場合、null
	ProfitLossRate *float64 `json:"ProfitLossRate,omitempty"`

	// SecurityType 銘柄種別<br>※先物・オプション銘柄の場合のみ
	SecurityType *int32 `json:"SecurityType,omitempty"`

	// Side 売買区分
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>売</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>買</td>
	//       </tr>
	//   </tbody>
	// </table>
	Side *string `json:"Side,omitempty"`

	// Symbol 銘柄コード
	Symbol *string `json:"Symbol,omitempty"`

	// SymbolName 銘柄名
	SymbolName *string `json:"SymbolName,omitempty"`

	// Valuation 評価金額<br>追加情報出力フラグ：falseの場合、null
	Valuation *float64 `json:"Valuation,omitempty"`
}

// PrimaryExchangeResponse defines model for PrimaryExchangeResponse.
type PrimaryExchangeResponse struct {
	// PrimaryExchange 優先市場
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>東証</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>名証</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>福証</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>札証</td>
	//       </tr>
	//   </tbody>
	// </table>
	PrimaryExchange *int32 `json:"PrimaryExchange,omitempty"`

	// Symbol 銘柄コード<br>※対象商品は、株式のみ
	Symbol *string `json:"Symbol,omitempty"`
}

// RankingByCategoryResponse defines model for RankingByCategoryResponse.
type RankingByCategoryResponse struct {
	// ExchangeDivision 市場
	ExchangeDivision *string `json:"ExchangeDivision,omitempty"`

	// Ranking ランキング
	Ranking *[]struct {
		// AverageRanking 平均順位<br>※100位以下は「999」となります
		AverageRanking *float64 `json:"AverageRanking,omitempty"`

		// Category 業種コード
		Category *string `json:"Category,omitempty"`

		// CategoryName 業種名
		CategoryName *string `json:"CategoryName,omitempty"`

		// ChangePercentage 騰落率（%）
		ChangePercentage *float64 `json:"ChangePercentage,omitempty"`

		// ChangeRatio 前日比
		ChangeRatio *float64 `json:"ChangeRatio,omitempty"`

		// CurrentPrice 現在値
		CurrentPrice *float64 `json:"CurrentPrice,omitempty"`

		// CurrentPriceTime 時刻<br>HH:mm<br>※日付は返しません
		CurrentPriceTime *string `json:"CurrentPriceTime,omitempty"`

		// No 順位<br>※ランキング内で同じ順位が返却される場合があります（10位が2件など）
		No *int32 `json:"No,omitempty"`

		// Trend トレンド
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>内容</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>0</td>
		//           <td>対象データ無し</td>
		//       </tr>
		//       <tr>
		//           <td>1</td>
		//           <td>過去10営業日より20位以上上昇</td>
		//       </tr>
		//       <tr>
		//           <td>2</td>
		//           <td>過去10営業日より1～19位上昇</td>
		//       </tr>
		//       <tr>
		//           <td>3</td>
		//           <td>過去10営業日と変わらず</td>
		//       </tr>
		//       <tr>
		//           <td>4</td>
		//           <td>過去10営業日より1～19位下落</td>
		//       </tr>
		//       <tr>
		//           <td>5</td>
		//           <td>過去10営業日より20位以上下落</td>
		//       </tr>
		//   </tbody>
		// </table>
		Trend *string `json:"Trend,omitempty"`
	} `json:"Ranking,omitempty"`

	// Type 種別<br> ※業種別値上がり率、業種別値下がり率の場合、市場は「null」になります
	Type *string `json:"Type,omitempty"`
}

// RankingByMarginResponse defines model for RankingByMarginResponse.
type RankingByMarginResponse struct {
	// ExchangeDivision 市場
	ExchangeDivision *string `json:"ExchangeDivision,omitempty"`

	// Ranking ランキング
	Ranking *[]struct {
		// BuyLastWeekRatio 買残前週比
		BuyLastWeekRatio *float64 `json:"BuyLastWeekRatio,omitempty"`

		// BuyRapidPaymentPercentage 買残（千株）
		BuyRapidPaymentPercentage *float64 `json:"BuyRapidPaymentPercentage,omitempty"`

		// CategoryName 業種名
		CategoryName *string `json:"CategoryName,omitempty"`

		// ExchangeName 市場名
		ExchangeName *string `json:"ExchangeName,omitempty"`

		// No 順位<br>※ランキング内で同じ順位が返却される場合があります（10位が2件など）
		No *int32 `json:"No,omitempty"`

		// Ratio 倍率
		Ratio *float64 `json:"Ratio,omitempty"`

		// SellLastWeekRatio 売残前週比
		SellLastWeekRatio *float64 `json:"SellLastWeekRatio,omitempty"`

		// SellRapidPaymentPercentage 売残（千株）
		SellRapidPaymentPercentage *float64 `json:"SellRapidPaymentPercentage,omitempty"`

		// Symbol 銘柄コード
		Symbol *string `json:"Symbol,omitempty"`

		// SymbolName 銘柄名称
		SymbolName *string `json:"SymbolName,omitempty"`
	} `json:"Ranking,omitempty"`

	// Type 種別
	Type *string `json:"Type,omitempty"`
}

// RankingByTickCountResponse defines model for RankingByTickCountResponse.
type RankingByTickCountResponse struct {
	// ExchangeDivision 市場
	ExchangeDivision *string `json:"ExchangeDivision,omitempty"`

	// Ranking ランキング
	Ranking *[]struct {
		// AverageRanking 平均順位<br>※100位以下は「999」となります
		AverageRanking *float64 `json:"AverageRanking,omitempty"`

		// CategoryName 業種名
		CategoryName *string `json:"CategoryName,omitempty"`

		// ChangePercentage 騰落率（%）
		ChangePercentage *float64 `json:"ChangePercentage,omitempty"`

		// ChangeRatio 前日比
		ChangeRatio *float64 `json:"ChangeRatio,omitempty"`

		// CurrentPrice 現在値
		CurrentPrice *float64 `json:"CurrentPrice,omitempty"`

		// DownCount DOWN
		DownCount *int32 `json:"DownCount,omitempty"`

		// ExchangeName 市場名
		ExchangeName *string `json:"ExchangeName,omitempty"`

		// No 順位<br>※ランキング内で同じ順位が返却される場合があります（10位が2件など）
		No *int32 `json:"No,omitempty"`

		// Symbol 銘柄コード
		Symbol *string `json:"Symbol,omitempty"`

		// SymbolName 銘柄名称
		SymbolName *string `json:"SymbolName,omitempty"`

		// TickCount TICK回数
		TickCount *int32 `json:"TickCount,omitempty"`

		// TradingVolume 売買高<br>売買高を千株単位で表示する<br>※百株の位を四捨五入
		TradingVolume *float64 `json:"TradingVolume,omitempty"`

		// Trend トレンド
		// <table>
		//     <thead>
		//         <tr>
		//             <th>定義値</th>
		//             <th>内容</th>
		//         </tr>
		//     </thead>
		//     <tbody>
		//         <tr>
		//             <td>0</td>
		//             <td>対象データ無し</td>
		//         </tr>
		//         <tr>
		//             <td>1</td>
		//             <td>過去10営業日より20位以上上昇</td>
		//         </tr>
		//         <tr>
		//             <td>2</td>
		//             <td>過去10営業日より1～19位上昇</td>
		//         </tr>
		//         <tr>
		//             <td>3</td>
		//             <td>過去10営業日と変わらず</td>
		//         </tr>
		//         <tr>
		//             <td>4</td>
		//             <td>過去10営業日より1～19位下落</td>
		//         </tr>
		//         <tr>
		//             <td>5</td>
		//             <td>過去10営業日より20位以上下落</td>
		//         </tr>
		//     </tbody>
		// </table>
		Trend *string `json:"Trend,omitempty"`

		// Turnover 売買代金<br>売買代金を百万円単位で表示する<br>※十万円の位を四捨五入
		Turnover *float64 `json:"Turnover,omitempty"`

		// UpCount UP
		UpCount *int32 `json:"UpCount,omitempty"`
	} `json:"Ranking,omitempty"`

	// Type 種別
	Type *string `json:"Type,omitempty"`
}

// RankingByTradeValueResponse defines model for RankingByTradeValueResponse.
type RankingByTradeValueResponse struct {
	// ExchangeDivision 市場
	ExchangeDivision *string `json:"ExchangeDivision,omitempty"`

	// Ranking ランキング
	Ranking *[]struct {
		// AverageRanking 平均順位<br>※100位以下は「999」となります
		AverageRanking *float64 `json:"AverageRanking,omitempty"`

		// CategoryName 業種名
		CategoryName *string `json:"CategoryName,omitempty"`

		// ChangePercentage 騰落率（%）
		ChangePercentage *float64 `json:"ChangePercentage,omitempty"`

		// ChangeRatio 前日比
		ChangeRatio *float64 `json:"ChangeRatio,omitempty"`

		// CurrentPrice 現在値
		CurrentPrice *float64 `json:"CurrentPrice,omitempty"`

		// CurrentPriceTime 時刻<br>HH:mm<br>※日付は返しません
		CurrentPriceTime *string `json:"CurrentPriceTime,omitempty"`

		// ExchangeName 市場名
		ExchangeName *string `json:"ExchangeName,omitempty"`

		// No 順位<br>※ランキング内で同じ順位が返却される場合があります（10位が2件など）
		No *int32 `json:"No,omitempty"`

		// RapidPaymentPercentage 代金急増（％）
		RapidPaymentPercentage *float64 `json:"RapidPaymentPercentage,omitempty"`

		// Symbol 銘柄コード
		Symbol *string `json:"Symbol,omitempty"`

		// SymbolName 銘柄名称
		SymbolName *string `json:"SymbolName,omitempty"`

		// Trend トレンド
		// <table>
		//     <thead>
		//         <tr>
		//             <th>定義値</th>
		//             <th>内容</th>
		//         </tr>
		//     </thead>
		//     <tbody>
		//         <tr>
		//             <td>0</td>
		//             <td>対象データ無し</td>
		//         </tr>
		//         <tr>
		//             <td>1</td>
		//             <td>過去10営業日より20位以上上昇</td>
		//         </tr>
		//         <tr>
		//             <td>2</td>
		//             <td>過去10営業日より1～19位上昇</td>
		//         </tr>
		//         <tr>
		//             <td>3</td>
		//             <td>過去10営業日と変わらず</td>
		//         </tr>
		//         <tr>
		//             <td>4</td>
		//             <td>過去10営業日より1～19位下落</td>
		//         </tr>
		//         <tr>
		//             <td>5</td>
		//             <td>過去10営業日より20位以上下落</td>
		//         </tr>
		//     </tbody>
		// </table>
		Trend *string `json:"Trend,omitempty"`

		// Turnover 売買代金<br>売買代金を百万円単位で表示する<br>※十万円の位を四捨五入
		Turnover *float64 `json:"Turnover,omitempty"`
	} `json:"Ranking,omitempty"`

	// Type 種別
	Type *string `json:"Type,omitempty"`
}

// RankingByTradeVolumeResponse defines model for RankingByTradeVolumeResponse.
type RankingByTradeVolumeResponse struct {
	// ExchangeDivision 市場
	ExchangeDivision *string `json:"ExchangeDivision,omitempty"`

	// Ranking ランキング
	Ranking *[]struct {
		// AverageRanking 平均順位<br>※100位以下は「999」となります
		AverageRanking *float64 `json:"AverageRanking,omitempty"`

		// CategoryName 業種名
		CategoryName *string `json:"CategoryName,omitempty"`

		// ChangePercentage 騰落率（%）
		ChangePercentage *float64 `json:"ChangePercentage,omitempty"`

		// ChangeRatio 前日比
		ChangeRatio *float64 `json:"ChangeRatio,omitempty"`

		// CurrentPrice 現在値
		CurrentPrice *float64 `json:"CurrentPrice,omitempty"`

		// CurrentPriceTime 時刻<br>HH:mm<br>※日付は返しません
		CurrentPriceTime *string `json:"CurrentPriceTime,omitempty"`

		// ExchangeName 市場名
		ExchangeName *string `json:"ExchangeName,omitempty"`

		// No 順位<br>※ランキング内で同じ順位が返却される場合があります（10位が2件など）
		No *int32 `json:"No,omitempty"`

		// RapidTradePercentage 売買高急増（％）
		RapidTradePercentage *float64 `json:"RapidTradePercentage,omitempty"`

		// Symbol 銘柄コード
		Symbol *string `json:"Symbol,omitempty"`

		// SymbolName 銘柄名称
		SymbolName *string `json:"SymbolName,omitempty"`

		// TradingVolume 売買高<br>売買高を千株単位で表示する<br>※百株の位を四捨五入
		TradingVolume *float64 `json:"TradingVolume,omitempty"`

		// Trend トレンド
		// <table>
		//     <thead>
		//         <tr>
		//             <th>定義値</th>
		//             <th>内容</th>
		//         </tr>
		//     </thead>
		//     <tbody>
		//         <tr>
		//             <td>0</td>
		//             <td>対象データ無し</td>
		//         </tr>
		//         <tr>
		//             <td>1</td>
		//             <td>過去10営業日より20位以上上昇</td>
		//         </tr>
		//         <tr>
		//             <td>2</td>
		//             <td>過去10営業日より1～19位上昇</td>
		//         </tr>
		//         <tr>
		//             <td>3</td>
		//             <td>過去10営業日と変わらず</td>
		//         </tr>
		//         <tr>
		//             <td>4</td>
		//             <td>過去10営業日より1～19位下落</td>
		//         </tr>
		//         <tr>
		//             <td>5</td>
		//             <td>過去10営業日より20位以上下落</td>
		//         </tr>
		//     </tbody>
		// </table>
		Trend *string `json:"Trend,omitempty"`
	} `json:"Ranking,omitempty"`

	// Type 種別
	Type *string `json:"Type,omitempty"`
}

// RankingDefaultResponse defines model for RankingDefaultResponse.
type RankingDefaultResponse struct {
	// ExchangeDivision 市場
	ExchangeDivision *string `json:"ExchangeDivision,omitempty"`

	// Ranking ランキング
	Ranking *[]struct {
		// AverageRanking 平均順位<br>※100位以下は「999」となります
		AverageRanking *float64 `json:"AverageRanking,omitempty"`

		// CategoryName 業種名
		CategoryName *string `json:"CategoryName,omitempty"`

		// ChangePercentage 騰落率（%）
		ChangePercentage *float64 `json:"ChangePercentage,omitempty"`

		// ChangeRatio 前日比
		ChangeRatio *float64 `json:"ChangeRatio,omitempty"`

		// CurrentPrice 現在値
		CurrentPrice *float64 `json:"CurrentPrice,omitempty"`

		// CurrentPriceTime 時刻<br>HH:mm<br>※日付は返しません
		CurrentPriceTime *string `json:"CurrentPriceTime,omitempty"`

		// ExchangeName 市場名
		ExchangeName *string `json:"ExchangeName,omitempty"`

		// No 順位<br>※ランキング内で同じ順位が返却される場合があります（10位が2件など）
		No *int32 `json:"No,omitempty"`

		// Symbol 銘柄コード
		Symbol *string `json:"Symbol,omitempty"`

		// SymbolName 銘柄名称
		SymbolName *string `json:"SymbolName,omitempty"`

		// TradingVolume 売買高<br>売買高を千株単位で表示する<br>※百株の位を四捨五入
		TradingVolume *float64 `json:"TradingVolume,omitempty"`

		// Trend トレンド
		// <table>
		//     <thead>
		//         <tr>
		//             <th>定義値</th>
		//             <th>内容</th>
		//         </tr>
		//     </thead>
		//     <tbody>
		//         <tr>
		//             <td>0</td>
		//             <td>対象データ無し</td>
		//         </tr>
		//         <tr>
		//             <td>1</td>
		//             <td>過去10営業日より20位以上上昇</td>
		//         </tr>
		//         <tr>
		//             <td>2</td>
		//             <td>過去10営業日より1～19位上昇</td>
		//         </tr>
		//         <tr>
		//             <td>3</td>
		//             <td>過去10営業日と変わらず</td>
		//         </tr>
		//         <tr>
		//             <td>4</td>
		//             <td>過去10営業日より1～19位下落</td>
		//         </tr>
		//         <tr>
		//             <td>5</td>
		//             <td>過去10営業日より20位以上下落</td>
		//         </tr>
		//     </tbody>
		// </table>
		Trend *string `json:"Trend,omitempty"`

		// Turnover 売買代金<br>売買代金を百万円単位で表示する<br>※十万円の位を四捨五入
		Turnover *float64 `json:"Turnover,omitempty"`
	} `json:"Ranking,omitempty"`

	// Type 種別
	Type *string `json:"Type,omitempty"`
}

// RegistSuccess defines model for RegistSuccess.
type RegistSuccess struct {
	// RegistList 現在登録されている銘柄のリスト
	RegistList *[]struct {
		// Exchange 市場コード
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>1</td>
		//           <td>東証</td>
		//       </tr>
		//       <tr>
		//           <td>3</td>
		//           <td>名証</td>
		//       </tr>
		//       <tr>
		//           <td>5</td>
		//           <td>福証</td>
		//       </tr>
		//       <tr>
		//           <td>6</td>
		//           <td>札証</td>
		//       </tr>
		//       <tr>
		//           <td>2</td>
		//           <td>日通し</td>
		//       </tr>
		//       <tr>
		//           <td>23</td>
		//           <td>日中</td>
		//       </tr>
		//       <tr>
		//           <td>24</td>
		//           <td>夜間</td>
		//       </tr>
		//   </tbody>
		// </table>
		Exchange *int32 `json:"Exchange,omitempty"`

		// Symbol 銘柄コード
		Symbol *string `json:"Symbol,omitempty"`
	} `json:"RegistList,omitempty"`
}

// RegulationsResponse defines model for RegulationsResponse.
type RegulationsResponse struct {
	// RegulationsInfo 規制情報
	RegulationsInfo *[]struct {
		// Exchange 規制市場
		// <table>
		//   <thead>
		//     <tr>
		//       <th>定義値</th>
		//       <th>内容</th>
		//     </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>0</td>
		//       <td>全対象</td>
		//     </tr>
		//     <tr>
		//       <td>1</td>
		//       <td>東証</td>
		//     </tr>
		//     <tr>
		//       <td>3</td>
		//       <td>名証</td>
		//     </tr>
		//     <tr>
		//       <td>5</td>
		//       <td>福証</td>
		//     </tr>
		//     <tr>
		//       <td>6</td>
		//       <td>札証</td>
		//     </tr>
		//     <tr>
		//       <td>9</td>
		//       <td>SOR</td>
		//     </tr>
		//     <tr>
		//       <td>10</td>
		//       <td>CXJ</td>
		//     </tr>
		//     <tr>
		//       <td>21</td>
		//       <td>JNX</td>
		//     </tr>
		//   </tbody>
		// </table>
		Exchange *int32 `json:"Exchange,omitempty"`

		// Level コンプライアンスレベル<br>
		// ※空売り規制の場合、null
		// <table>
		//   <thead>
		//     <tr>
		//       <th>定義値</th>
		//       <th>内容</th>
		//     </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>０</td>
		//       <td>規制無し</td>
		//     </tr>
		//     <tr>
		//       <td>１</td>
		//       <td>ワーニング</td>
		//     </tr>
		//     <tr>
		//       <td>２</td>
		//       <td>エラー</td>
		//     </tr>
		//   </tbody>
		// </table>
		Level *int32 `json:"Level,omitempty"`

		// LimitEndDay 制限終了日<br>yyyy/MM/dd HH:mm形式  <br>※空売り規制の場合、null
		LimitEndDay *string `json:"LimitEndDay,omitempty"`

		// LimitStartDay 制限開始日<br>yyyy/MM/dd HH:mm形式  <br>※空売り規制の場合、null
		LimitStartDay *string `json:"LimitStartDay,omitempty"`

		// Product 規制取引区分<br>
		// ※空売り規制の場合、「4：新規」
		// <table>
		//   <thead>
		//     <tr>
		//       <th>定義値</th>
		//       <th>内容</th>
		//     </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>0</td>
		//       <td>全対象</td>
		//     </tr>
		//     <tr>
		//       <td>1</td>
		//       <td>現物</td>
		//     </tr>
		//     <tr>
		//       <td>2</td>
		//       <td>信用新規（制度）</td>
		//     </tr>
		//     <tr>
		//       <td>3</td>
		//       <td>信用新規（一般）</td>
		//     </tr>
		//     <tr>
		//       <td>4</td>
		//       <td>新規</td>
		//     </tr>
		//     <tr>
		//       <td>5</td>
		//       <td>信用返済（制度）</td>
		//     </tr>
		//     <tr>
		//       <td>6</td>
		//       <td>信用返済（一般）</td>
		//     </tr>
		//     <tr>
		//       <td>7</td>
		//       <td>返済</td>
		//     </tr>
		//     <tr>
		//       <td>8</td>
		//       <td>品受</td>
		//     </tr>
		//     <tr>
		//       <td>9</td>
		//       <td>品渡</td>
		//     </tr>
		//   </tbody>
		// </table>
		Product *int32 `json:"Product,omitempty"`

		// Reason 理由<br>※空売り規制の場合、「空売り規制」
		Reason *string `json:"Reason,omitempty"`

		// Side 規制売買<br>
		// ※空売り規制の場合、「1：売」
		// <table>
		//   <thead>
		//     <tr>
		//       <th>定義値</th>
		//       <th>内容</th>
		//     </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>0</td>
		//       <td>全対象</td>
		//     </tr>
		//     <tr>
		//       <td>1</td>
		//       <td>売</td>
		//     </tr>
		//     <tr>
		//       <td>2</td>
		//       <td>買</td>
		//     </tr>
		//   </tbody>
		// </table>
		Side *string `json:"Side,omitempty"`
	} `json:"RegulationsInfo,omitempty"`

	// Symbol 銘柄コード<br>
	// ※対象商品は、株式のみ
	Symbol *string `json:"Symbol,omitempty"`
}

// RequestCancelOrder defines model for RequestCancelOrder.
type RequestCancelOrder struct {
	// OrderId 注文番号<br>sendorderのレスポンスで受け取るOrderID。
	OrderId string `json:"OrderId"`

	// Password 注文パスワード
	Password string `json:"Password"`
}

// RequestRegister defines model for RequestRegister.
type RequestRegister struct {
	Symbols *[]struct {
		// Exchange 市場コード
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>1</td>
		//           <td>東証</td>
		//       </tr>
		//       <tr>
		//           <td>3</td>
		//           <td>名証</td>
		//       </tr>
		//       <tr>
		//           <td>5</td>
		//           <td>福証</td>
		//       </tr>
		//       <tr>
		//           <td>6</td>
		//           <td>札証</td>
		//       </tr>
		//       <tr>
		//           <td>2</td>
		//           <td>日通し</td>
		//       </tr>
		//       <tr>
		//           <td>23</td>
		//           <td>日中</td>
		//       </tr>
		//       <tr>
		//           <td>24</td>
		//           <td>夜間</td>
		//       </tr>
		//   </tbody>
		// </table>
		Exchange *int32 `json:"Exchange,omitempty"`

		// Symbol 銘柄コード
		Symbol *string `json:"Symbol,omitempty"`
	} `json:"Symbols,omitempty"`
}

// RequestSendOrder defines model for RequestSendOrder.
type RequestSendOrder struct {
	// AccountType 口座種別
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>2</td>
	//           <td>一般</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>特定</td>
	//       </tr>
	//       <tr>
	//           <td>12</td>
	//           <td>法人</td>
	//       </tr>
	//   </tbody>
	// </table>
	AccountType int32 `json:"AccountType"`

	// CashMargin 信用区分
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>現物</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>新規</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>返済</td>
	//       </tr>
	//   </tbody>
	// </table>
	CashMargin int32 `json:"CashMargin"`

	// ClosePositionOrder 決済順序<br>※信用返済の場合、必須。<br>※ClosePositionOrderとClosePositionsはどちらか一方のみ指定可能。<br>※ClosePositionOrderとClosePositionsを両方指定した場合、エラー。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0</td>
	//           <td>日付（古い順）、損益（高い順）</td>
	//       </tr>
	//       <tr>
	//           <td>1</td>
	//           <td>日付（古い順）、損益（低い順）</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>日付（新しい順）、損益（高い順）</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>日付（新しい順）、損益（低い順）</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>損益（高い順）、日付（古い順）</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>損益（高い順）、日付（新しい順）</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>損益（低い順）、日付（古い順）</td>
	//       </tr>
	//       <tr>
	//           <td>7</td>
	//           <td>損益（低い順）、日付（新しい順）</td>
	//       </tr>
	//   </tbody>
	// </table>
	ClosePositionOrder *int32 `json:"ClosePositionOrder,omitempty"`

	// ClosePositions 返済建玉指定<br>※信用返済の場合、必須。<br>※ClosePositionOrderとClosePositionsはどちらか一方のみ指定可能。<br>※ClosePositionOrderとClosePositionsを両方指定した場合、エラー。<br>※信用一括返済の場合、各建玉IDと返済したい数量を入力してください。<br>※建玉IDは「E」から始まる番号です。
	ClosePositions *[]Positions `json:"ClosePositions,omitempty"`

	// DelivType 受渡区分<br>※現物買は指定必須。<br>※現物売は「0(指定なし)」を設定<br>※信用新規は「0(指定なし)」を設定<br>※信用返済は指定必須
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0</td>
	//           <td>指定なし</td>
	//       </tr>
	//       <tr>
	//           <td>1</td>
	//           <td>自動振替</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>お預り金</td>
	//       </tr>
	//   </tbody>
	// </table>
	DelivType int32 `json:"DelivType"`

	// Exchange 市場コード
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>東証</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>名証</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>福証</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>札証</td>
	//       </tr>
	//   </tbody>
	// </table>
	Exchange int32 `json:"Exchange"`

	// ExpireDay 注文有効期限<br>
	// yyyyMMdd形式。<br>
	// 「0」を指定すると、kabuステーション上の発注画面の「本日」に対応する日付として扱います。<br>
	// 「本日」は直近の注文可能日となり、以下のように設定されます。<br>
	// 引けまでの間 : 当日<br>
	// 引け後       : 翌取引所営業日<br>
	// 休前日       : 休日明けの取引所営業日<br>
	// ※ 日替わりはkabuステーションが日付変更通知を受信したタイミングです。
	ExpireDay int32 `json:"ExpireDay"`

	// FrontOrderType 執行条件
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//           <th>”Price"の指定</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>10</td>
	//           <td>成行</td>
	//           <td>0</td>
	//       </tr>
	//       <tr>
	//           <td>13</td>
	//           <td>寄成（前場）</td>
	//           <td>0</td>
	//       </tr>
	//       <tr>
	//           <td>14</td>
	//           <td>寄成（後場）</td>
	//           <td>0</td>
	//       </tr>
	//       <tr>
	//           <td>15</td>
	//           <td>引成（前場）</td>
	//           <td>0</td>
	//       </tr>
	//       <tr>
	//           <td>16</td>
	//           <td>引成（後場）</td>
	//           <td>0</td>
	//       </tr>
	//       <tr>
	//           <td>17</td>
	//           <td>IOC成行</td>
	//           <td>0</td>
	//       </tr>
	//       <tr>
	//           <td>20</td>
	//           <td>指値</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>21</td>
	//           <td>寄指（前場）</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>22</td>
	//           <td>寄指（後場）</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>23</td>
	//           <td>引指（前場）</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>24</td>
	//           <td>引指（後場）</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>25</td>
	//           <td>不成（前場）</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>26</td>
	//           <td>不成（後場）</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>27</td>
	//           <td>IOC指値</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>30</td>
	//           <td>逆指値</td>
	//           <td>指定なし<br>※AfterHitPriceで指定ください</td>
	//       </tr>
	//   </tbody>
	// </table>
	FrontOrderType int32 `json:"FrontOrderType"`

	// FundType 資産区分（預り区分）<br>※現物買は、指定必須。<br>※現物売は、「'  '」 半角スペース2つを指定必須。<br>※信用新規と信用返済は、指定不要。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>(半角スペース2つ)</td>
	//           <td>現物売の場合</td>
	//       </tr>
	//       <tr>
	//           <td>02</td>
	//           <td>保護</td>
	//       </tr>
	//       <tr>
	//           <td>AA</td>
	//           <td>信用代用</td>
	//       </tr>
	//       <tr>
	//           <td>11</td>
	//           <td>信用取引</td>
	//       </tr>
	//   </tbody>
	// </table>
	FundType *string `json:"FundType,omitempty"`

	// MarginPremiumUnit １株あたりのプレミアム料(円)<br>
	// ※プレミアム料の刻値は、プレミアム料取得APIのレスポンスにある"TickMarginPremium"にてご確認ください。<br>
	// ※入札受付中(19:30～20:30)プレミアム料入札可能銘柄の場合、「MarginPremiumUnit」は必須となります。<br>
	// ※入札受付中(19:30～20:30)のプレミアム料入札可能銘柄以外の場合は、「MarginPremiumUnit」の記載は無視されます。<br>
	// ※入札受付中以外の時間帯では、「MarginPremiumUnit」の記載は無視されます。
	MarginPremiumUnit *float64 `json:"MarginPremiumUnit,omitempty"`

	// MarginTradeType 信用取引区分<br>※現物取引の場合は指定不要。<br>※信用取引の場合、必須。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>制度信用</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>一般信用（長期）</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>一般信用（デイトレ）</td>
	//       </tr>
	//   </tbody>
	// </table>
	MarginTradeType *int32 `json:"MarginTradeType,omitempty"`

	// Password 注文パスワード
	Password string `json:"Password"`

	// Price 注文価格<br>※FrontOrderTypeで成行を指定した場合、0を指定する。<br>※詳細について、”FrontOrderType”をご確認ください。
	Price float64 `json:"Price"`

	// Qty 注文数量<br>※信用一括返済の場合、返済したい合計数量を入力してください。
	Qty int32 `json:"Qty"`

	// ReverseLimitOrder 逆指値条件<br>
	// ※FrontOrderTypeで逆指値を指定した場合のみ必須。
	ReverseLimitOrder *struct {
		// AfterHitOrderType ヒット後執行条件<br>
		// ※未設定の場合はエラーになります。<br>
		// ※1、2、3以外が指定された場合はエラーになります。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>1</td>
		//       <td>成行</td>
		//     </tr>
		//     <tr>
		//       <td>2</td>
		//       <td>指値</td>
		//     </tr>
		//     <tr>
		//       <td>3</td>
		//       <td>不成</td>
		//     </tr>
		//   </tbody>
		// </table>
		AfterHitOrderType int32 `json:"AfterHitOrderType"`

		// AfterHitPrice ヒット後注文価格<br>
		// ※未設定の場合はエラーになります。<br>
		// ※数字以外が設定された場合はエラーになります。<br><br>
		// ヒット後執行条件に従い、下記のようにヒット後注文価格を設定してください。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>ヒット後執行条件</th>
		//           <th>設定価格</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>成行</td>
		//       <td>0</td>
		//     </tr>
		//     <tr>
		//       <td>指値</td>
		//       <td>指値の単価</td>
		//     </tr>
		//     <tr>
		//       <td>不成</td>
		//       <td>不成の単価</td>
		//     </tr>
		//   </tbody>
		// </table>
		AfterHitPrice float64 `json:"AfterHitPrice"`

		// TriggerPrice トリガ価格<br>
		// ※未設定の場合はエラーになります。<br>
		// ※数字以外が設定された場合はエラーになります。
		TriggerPrice float64 `json:"TriggerPrice"`

		// TriggerSec トリガ銘柄<br>
		// ※未設定の場合はエラーになります。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>1</td>
		//       <td>発注銘柄</td>
		//     </tr>
		//     <tr>
		//       <td>2</td>
		//       <td>NK225指数</td>
		//     </tr>
		//     <tr>
		//       <td>3</td>
		//       <td>TOPIX指数</td>
		//     </tr>
		//   </tbody>
		// </table>
		TriggerSec int32 `json:"TriggerSec"`

		// UnderOver 以上／以下<br>
		// ※未設定の場合はエラーになります。<br>
		// ※1、2以外が指定された場合はエラーになります。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>1</td>
		//       <td>以下</td>
		//     </tr>
		//     <tr>
		//       <td>2</td>
		//       <td>以上</td>
		//     </tr>
		//   </tbody>
		// </table>
		UnderOver int32 `json:"UnderOver"`
	} `json:"ReverseLimitOrder,omitempty"`

	// SecurityType 商品種別
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>株式</td>
	//       </tr>
	//   </tbody>
	// </table>
	SecurityType int32 `json:"SecurityType"`

	// Side 売買区分
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>売</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>買</td>
	//       </tr>
	//   </tbody>
	// </table>
	Side string `json:"Side"`

	// Symbol 銘柄コード
	Symbol string `json:"Symbol"`
}

// RequestSendOrderDerivFuture defines model for RequestSendOrderDerivFuture.
type RequestSendOrderDerivFuture struct {
	// ClosePositionOrder 決済順序<br>※ClosePositionOrderとClosePositionsはどちらか一方のみ指定可能。<br>※ClosePositionOrderとClosePositionsを両方指定した場合、エラー。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0</td>
	//           <td>日付（古い順）、損益（高い順）</td>
	//       </tr>
	//       <tr>
	//           <td>1</td>
	//           <td>日付（古い順）、損益（低い順）</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>日付（新しい順）、損益（高い順）</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>日付（新しい順）、損益（低い順）</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>損益（高い順）、日付（古い順）</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>損益（高い順）、日付（新しい順）</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>損益（低い順）、日付（古い順）</td>
	//       </tr>
	//       <tr>
	//           <td>7</td>
	//           <td>損益（低い順）、日付（新しい順）</td>
	//       </tr>
	//   </tbody>
	// </table>
	ClosePositionOrder *int32 `json:"ClosePositionOrder,omitempty"`

	// ClosePositions 返済建玉指定<br>※ClosePositionOrderとClosePositionsはどちらか一方のみ指定可能。<br>※ClosePositionOrderとClosePositionsを両方指定した場合、エラー。
	ClosePositions *[]PositionsDeriv `json:"ClosePositions,omitempty"`

	// Exchange 市場コード
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>2</td>
	//           <td>日通し</td>
	//       </tr>
	//       <tr>
	//           <td>23</td>
	//           <td>日中</td>
	//       </tr>
	//       <tr>
	//           <td>24</td>
	//           <td>夜間</td>
	//       </tr>
	//   </tbody>
	// </table>
	Exchange int32 `json:"Exchange"`

	// ExpireDay 注文有効期限<br>
	// yyyyMMdd形式。<br>
	// 「0」を指定すると、kabuステーション上の発注画面の「本日」に対応する日付として扱います。<br>
	// 「本日」は直近の注文可能日となり、以下のように設定されます。<br>
	// その市場の引けまでの間 : 当日<br>
	// その市場の引け後       : 翌取引所営業日<br>
	// その市場の休前日       : 休日明けの取引所営業日<br>
	// ※ 日替わりはkabuステーションが日付変更通知を受信したタイミングです。<br>
	// ※ 日通しの場合、夜間取引の引け後に日付が更新されます。
	ExpireDay int32 `json:"ExpireDay"`

	// FrontOrderType 執行条件
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//           <th>”Price”の指定</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>18</td>
	//           <td>引成（派生）<br>※TimeInForceは、「FAK」のみ有効</td>
	//           <td>0</td>
	//       </tr>
	//       <tr>
	//           <td>20</td>
	//           <td>指値</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>28</td>
	//           <td>引指（派生）<br>※TimeInForceは、「FAS」のみ有効</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>30</td>
	//           <td>逆指値</td>
	//           <td>指定なし<br>※AfterHitPriceで指定ください</td>
	//       </tr>
	//       <tr>
	//           <td>120</td>
	//           <td>成行（マーケットオーダー）</td>
	//           <td>0</td>
	//       </tr>
	//   </tbody>
	// </table>
	FrontOrderType int32 `json:"FrontOrderType"`

	// Password 注文パスワード
	Password string `json:"Password"`

	// Price 注文価格<br>※FrontOrderTypeで成行を指定した場合、0を指定する。<br>※詳細について、”FrontOrderType”をご確認ください。
	Price float64 `json:"Price"`

	// Qty 注文数量
	Qty int32 `json:"Qty"`

	// ReverseLimitOrder 逆指値条件<br>
	// ※FrontOrderTypeで逆指値を指定した場合のみ必須。
	ReverseLimitOrder *struct {
		// AfterHitOrderType ヒット後執行条件<br>
		// ※未設定の場合はエラーになります。<br>
		// ※日通の注文で2以外が指定された場合はエラーになります。<br>
		// ※日中、夜間の注文で1、2以外が指定された場合はエラーになります。<br>
		// ※逆指値（成行）で有効期間条件(TimeInForce)にFAK以外を指定された場合はエラーになります。<br>
		// ※逆指値（指値）で有効期間条件(TimeInForce)にFAS以外を指定された場合はエラーになります。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>1</td>
		//       <td>成行</td>
		//     </tr>
		//     <tr>
		//       <td>2</td>
		//       <td>指値</td>
		//     </tr>
		//   </tbody>
		// </table>
		AfterHitOrderType int32 `json:"AfterHitOrderType"`

		// AfterHitPrice ヒット後注文価格<br>
		// ※未設定の場合はエラーになります。<br>
		// ※数字以外が設定された場合はエラーになります。<br><br>
		// ヒット後執行条件に従い、下記のようにヒット後注文価格を設定してください。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>ヒット後執行条件</th>
		//           <th>設定価格</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>成行</td>
		//       <td>0</td>
		//     </tr>
		//     <tr>
		//       <td>指値</td>
		//       <td>指値の単価</td>
		//     </tr>
		//   </tbody>
		// </table>
		AfterHitPrice float64 `json:"AfterHitPrice"`

		// TriggerPrice トリガ価格<br>
		// ※未設定の場合はエラーになります。<br>
		// ※数字以外が設定された場合はエラーになります。
		TriggerPrice float64 `json:"TriggerPrice"`

		// UnderOver 以上／以下<br>
		// ※未設定の場合はエラーになります。<br>
		// ※1、2以外が指定された場合はエラーになります。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>1</td>
		//       <td>以下</td>
		//     </tr>
		//     <tr>
		//       <td>2</td>
		//       <td>以上</td>
		//     </tr>
		//   </tbody>
		// </table>
		UnderOver int32 `json:"UnderOver"`
	} `json:"ReverseLimitOrder,omitempty"`

	// Side 売買区分
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>売</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>買</td>
	//       </tr>
	//   </tbody>
	// </table>
	Side string `json:"Side"`

	// Symbol 銘柄コード<br>※取引最終日に「先物銘柄コード取得」でDerivMonthに0（直近限月）を指定した場合、日中・夜間の時間帯に関わらず、取引最終日を迎える限月の銘柄コードを返します。取引最終日を迎える銘柄の取引は日中取引をもって終了となりますので、ご注意ください。
	Symbol string `json:"Symbol"`

	// TimeInForce 有効期間条件
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>FAS<br>※逆指値注文以外の場合、FASを指定した場合、FrontOrderTypeは指値(20)のみ指定可能。</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>FAK<br>※逆指値注文以外の場合、FAKを指定した場合、Exchangeは日中(23)、夜間(24)のみ指定可能。</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>FOK<br>※逆指値注文以外の場合、FOKを指定した場合、Exchangeは日中(23)、夜間(24)のみ指定可能。</td>
	//       </tr>
	//   </tbody>
	// </table>
	TimeInForce int32 `json:"TimeInForce"`

	// TradeType 取引区分
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>新規</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>返済</td>
	//       </tr>
	//   </tbody>
	// </table>
	TradeType int32 `json:"TradeType"`
}

// RequestSendOrderDerivOption defines model for RequestSendOrderDerivOption.
type RequestSendOrderDerivOption struct {
	// ClosePositionOrder 決済順序<br>※ClosePositionOrderとClosePositionsはどちらか一方のみ指定可能。<br>※ClosePositionOrderとClosePositionsを両方指定した場合、エラー。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0</td>
	//           <td>日付（古い順）、損益（高い順）</td>
	//       </tr>
	//       <tr>
	//           <td>1</td>
	//           <td>日付（古い順）、損益（低い順）</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>日付（新しい順）、損益（高い順）</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>日付（新しい順）、損益（低い順）</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>損益（高い順）、日付（古い順）</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>損益（高い順）、日付（新しい順）</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>損益（低い順）、日付（古い順）</td>
	//       </tr>
	//       <tr>
	//           <td>7</td>
	//           <td>損益（低い順）、日付（新しい順）</td>
	//       </tr>
	//   </tbody>
	// </table>
	ClosePositionOrder *int32 `json:"ClosePositionOrder,omitempty"`

	// ClosePositions 返済建玉指定<br>※ClosePositionOrderとClosePositionsはどちらか一方のみ指定可能。<br>※ClosePositionOrderとClosePositionsを両方指定した場合、エラー。
	ClosePositions *[]PositionsDeriv `json:"ClosePositions,omitempty"`

	// Exchange 市場コード
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>2</td>
	//           <td>日通し</td>
	//       </tr>
	//       <tr>
	//           <td>23</td>
	//           <td>日中</td>
	//       </tr>
	//       <tr>
	//           <td>24</td>
	//           <td>夜間</td>
	//       </tr>
	//   </tbody>
	// </table>
	Exchange int32 `json:"Exchange"`

	// ExpireDay 注文有効期限<br>
	// yyyyMMdd形式。<br>
	// 「0」を指定すると、kabuステーション上の発注画面の「本日」に対応する日付として扱います。<br>
	// 「本日」は直近の注文可能日となり、以下のように設定されます。<br>
	// その市場の引けまでの間 : 当日<br>
	// その市場の引け後       : 翌取引所営業日<br>
	// その市場の休前日       : 休日明けの取引所営業日<br>
	// ※ 日替わりはkabuステーションが日付変更通知を受信したタイミングです。<br>
	// ※ 日通しの場合、夜間取引の引け後に日付が更新されます。
	ExpireDay int32 `json:"ExpireDay"`

	// FrontOrderType 執行条件
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//           <th>”Price”の指定</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>18</td>
	//           <td>引成（派生）<br>※TimeInForceは、「FAK」のみ有効</td>
	//           <td>0</td>
	//       </tr>
	//       <tr>
	//           <td>20</td>
	//           <td>指値</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>28</td>
	//           <td>引指（派生）<br>※TimeInForceは、「FAS」のみ有効</td>
	//           <td>発注したい金額</td>
	//       </tr>
	//       <tr>
	//           <td>30</td>
	//           <td>逆指値</td>
	//           <td>指定なし<br>※AfterHitPriceで指定ください</td>
	//       </tr>
	//       <tr>
	//           <td>120</td>
	//           <td>成行（マーケットオーダー）</td>
	//           <td>0</td>
	//       </tr>
	//   </tbody>
	// </table>
	FrontOrderType int32 `json:"FrontOrderType"`

	// Password 注文パスワード
	Password string `json:"Password"`

	// Price 注文価格<br>※FrontOrderTypeで成行を指定した場合、0を指定する。<br>※詳細について、”FrontOrderType”をご確認ください。
	Price float64 `json:"Price"`

	// Qty 注文数量
	Qty int32 `json:"Qty"`

	// ReverseLimitOrder 逆指値条件<br>
	// ※FrontOrderTypeで逆指値を指定した場合のみ必須。
	ReverseLimitOrder *struct {
		// AfterHitOrderType ヒット後執行条件<br>
		// ※未設定の場合はエラーになります。<br>
		// ※日通の注文で2以外が指定された場合はエラーになります。<br>
		// ※日中、夜間の注文で1、2以外が指定された場合はエラーになります。<br>
		// ※逆指値（成行）で有効期間条件(TimeInForce)にFAK以外を指定された場合はエラーになります。<br>
		// ※逆指値（指値）で有効期間条件(TimeInForce)にFAS以外を指定された場合はエラーになります。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>1</td>
		//       <td>成行</td>
		//     </tr>
		//     <tr>
		//       <td>2</td>
		//       <td>指値</td>
		//     </tr>
		//   </tbody>
		// </table>
		AfterHitOrderType int32 `json:"AfterHitOrderType"`

		// AfterHitPrice ヒット後注文価格<br>
		// ※未設定の場合はエラーになります。<br>
		// ※数字以外が設定された場合はエラーになります。<br><br>
		// ヒット後執行条件に従い、下記のようにヒット後注文価格を設定してください。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>ヒット後執行条件</th>
		//           <th>設定価格</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>成行</td>
		//       <td>0</td>
		//     </tr>
		//     <tr>
		//       <td>指値</td>
		//       <td>指値の単価</td>
		//     </tr>
		//   </tbody>
		// </table>
		AfterHitPrice float64 `json:"AfterHitPrice"`

		// TriggerPrice トリガ価格<br>
		// ※未設定の場合はエラーになります。<br>
		// ※数字以外が設定された場合はエラーになります。
		TriggerPrice float64 `json:"TriggerPrice"`

		// UnderOver 以上／以下<br>
		// ※未設定の場合はエラーになります。<br>
		// ※1、2以外が指定された場合はエラーになります。
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//     <tr>
		//       <td>1</td>
		//       <td>以下</td>
		//     </tr>
		//     <tr>
		//       <td>2</td>
		//       <td>以上</td>
		//     </tr>
		//   </tbody>
		// </table>
		UnderOver int32 `json:"UnderOver"`
	} `json:"ReverseLimitOrder,omitempty"`

	// Side 売買区分
	// <table>
	//   <thead>
	//     <tr>
	//       <th>定義値</th>
	//       <th>説明</th>
	//     </tr>
	//   </thead>
	//   <tbody>
	//     <tr>
	//       <td>1</td>
	//       <td>売</td>
	//     </tr>
	//     <tr>
	//       <td>2</td>
	//       <td>買</td>
	//     </tr>
	//   </tbody>
	// </table>
	Side string `json:"Side"`

	// Symbol 銘柄コード<br>※取引最終日に「オプション銘柄コード取得」でDerivMonthに0（直近限月）を指定した場合、日中・夜間の時間帯に関わらず、取引最終日を迎える限月の銘柄コードを返します。取引最終日を迎える銘柄の取引は日中取引をもって終了となりますので、ご注意ください。
	Symbol string `json:"Symbol"`

	// TimeInForce 有効期間条件
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>FAS<br>※逆指値注文以外の場合、FASを指定した場合、FrontOrderTypeは指値(20)のみ指定可能。</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>FAK<br>※逆指値注文以外の場合、FAKを指定した場合、Exchangeは日中(23)、夜間(24)のみ指定可能。</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>FOK<br>※逆指値注文以外の場合、FOKを指定した場合、Exchangeは日中(23)、夜間(24)のみ指定可能。</td>
	//       </tr>
	//   </tbody>
	// </table>
	TimeInForce int32 `json:"TimeInForce"`

	// TradeType 取引区分
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>新規</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>返済</td>
	//       </tr>
	//   </tbody>
	// </table>
	TradeType int32 `json:"TradeType"`
}

// RequestToken defines model for RequestToken.
type RequestToken struct {
	// APIPassword APIパスワード
	APIPassword string `json:"APIPassword"`
}

// RequestUnregister defines model for RequestUnregister.
type RequestUnregister struct {
	// Symbols ※為替銘柄を登録する場合、銘柄名は"通貨A" + "/" + "通貨B"、市場コードは"300"で指定してください。
	// 例：'Symbol': 'EUR/USD', "Exchange": 300
	Symbols *[]struct {
		// Exchange 市場コード
		// <table>
		//   <thead>
		//       <tr>
		//           <th>定義値</th>
		//           <th>説明</th>
		//       </tr>
		//   </thead>
		//   <tbody>
		//       <tr>
		//           <td>1</td>
		//           <td>東証</td>
		//       </tr>
		//       <tr>
		//           <td>3</td>
		//           <td>名証</td>
		//       </tr>
		//       <tr>
		//           <td>5</td>
		//           <td>福証</td>
		//       </tr>
		//       <tr>
		//           <td>6</td>
		//           <td>札証</td>
		//       </tr>
		//       <tr>
		//           <td>2</td>
		//           <td>日通し</td>
		//       </tr>
		//       <tr>
		//           <td>23</td>
		//           <td>日中</td>
		//       </tr>
		//       <tr>
		//           <td>24</td>
		//           <td>夜間</td>
		//       </tr>
		//   </tbody>
		// </table>
		Exchange *int32 `json:"Exchange,omitempty"`

		// Symbol 銘柄コード
		Symbol *string `json:"Symbol,omitempty"`
	} `json:"Symbols,omitempty"`
}

// SymbolNameSuccess defines model for SymbolNameSuccess.
type SymbolNameSuccess struct {
	// Symbol 銘柄コード
	Symbol *string `json:"Symbol,omitempty"`

	// SymbolName 銘柄名称
	SymbolName *string `json:"SymbolName,omitempty"`
}

// SymbolSuccess defines model for SymbolSuccess.
type SymbolSuccess struct {
	// BisCategory 業種コード名<br>※株式銘柄の場合のみ
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0050</td>
	//           <td>水産・農林業</td>
	//       </tr>
	//       <tr>
	//           <td>1050</td>
	//           <td>鉱業</td>
	//       </tr>
	//       <tr>
	//           <td>2050</td>
	//           <td>建設業</td>
	//       </tr>
	//       <tr>
	//           <td>3050</td>
	//           <td>食料品</td>
	//       </tr>
	//       <tr>
	//           <td>3100</td>
	//           <td>繊維製品</td>
	//       </tr>
	//       <tr>
	//           <td>3150</td>
	//           <td>パルプ・紙</td>
	//       </tr>
	//       <tr>
	//           <td>3200</td>
	//           <td>化学</td>
	//       </tr>
	//       <tr>
	//           <td>3250</td>
	//           <td>医薬品</td>
	//       </tr>
	//       <tr>
	//           <td>3300</td>
	//           <td>石油・石炭製品</td>
	//       </tr>
	//       <tr>
	//           <td>3350</td>
	//           <td>ゴム製品</td>
	//       </tr>
	//       <tr>
	//           <td>3400</td>
	//           <td>ガラス・土石製品</td>
	//       </tr>
	//       <tr>
	//           <td>3450</td>
	//           <td>鉄鋼</td>
	//       </tr>
	//       <tr>
	//           <td>3500</td>
	//           <td>非鉄金属</td>
	//       </tr>
	//       <tr>
	//           <td>3550</td>
	//           <td>金属製品</td>
	//       </tr>
	//       <tr>
	//           <td>3600</td>
	//           <td>機械</td>
	//       </tr>
	//       <tr>
	//           <td>3650</td>
	//           <td>電気機器</td>
	//       </tr>
	//       <tr>
	//           <td>3700</td>
	//           <td>輸送用機器</td>
	//       </tr>
	//       <tr>
	//           <td>3750</td>
	//           <td>精密機器</td>
	//       </tr>
	//       <tr>
	//           <td>3800</td>
	//           <td>その他製品</td>
	//       </tr>
	//       <tr>
	//           <td>4050</td>
	//           <td>電気・ガス業</td>
	//       </tr>
	//       <tr>
	//           <td>5050</td>
	//           <td>陸運業</td>
	//       </tr>
	//       <tr>
	//           <td>5100</td>
	//           <td>海運業</td>
	//       </tr>
	//       <tr>
	//           <td>5150</td>
	//           <td>空運業</td>
	//       </tr>
	//       <tr>
	//           <td>5200</td>
	//           <td>倉庫・運輸関連業</td>
	//       </tr>
	//       <tr>
	//           <td>5250</td>
	//           <td>情報・通信業</td>
	//       </tr>
	//       <tr>
	//           <td>6050</td>
	//           <td>卸売業</td>
	//       </tr>
	//       <tr>
	//           <td>6100</td>
	//           <td>小売業</td>
	//       </tr>
	//       <tr>
	//           <td>7050</td>
	//           <td>銀行業</td>
	//       </tr>
	//       <tr>
	//           <td>7100</td>
	//           <td>証券、商品先物取引業</td>
	//       </tr>
	//       <tr>
	//           <td>7150</td>
	//           <td>保険業</td>
	//       </tr>
	//       <tr>
	//           <td>7200</td>
	//           <td>その他金融業</td>
	//       </tr>
	//       <tr>
	//           <td>8050</td>
	//           <td>不動産業</td>
	//       </tr>
	//       <tr>
	//           <td>9050</td>
	//           <td>サービス業</td>
	//       </tr>
	//       <tr>
	//           <td>9999</td>
	//           <td>その他</td>
	//       </tr>
	//   </tbody>
	// </table>
	BisCategory *string `json:"BisCategory,omitempty"`

	// ClearingPrice 清算値<br>※先物銘柄の場合のみ<br>追加情報出力フラグ：falseの場合、null
	ClearingPrice *float64 `json:"ClearingPrice,omitempty"`

	// DerivMonth 限月-年月<br>※「限月-年月」は「年(yyyy)/月(MM)」で表示します。<br>※先物・オプション銘柄の場合のみ
	DerivMonth *string `json:"DerivMonth,omitempty"`

	// DisplayName 銘柄略称<br>※株式・先物・オプション銘柄の場合のみ
	DisplayName *string `json:"DisplayName,omitempty"`

	// Exchange 市場コード<br>※株式・先物・オプション銘柄の場合のみ
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>東証</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>名証</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>福証</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>札証</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>日通し</td>
	//       </tr>
	//       <tr>
	//           <td>23</td>
	//           <td>日中</td>
	//       </tr>
	//       <tr>
	//           <td>24</td>
	//           <td>夜間</td>
	//       </tr>
	//   </tbody>
	// </table>
	Exchange *int32 `json:"Exchange,omitempty"`

	// ExchangeName 市場名称<br>※株式・先物・オプション銘柄の場合のみ
	ExchangeName *string `json:"ExchangeName,omitempty"`

	// FiscalYearEndBasic 決算期日<br>※株式銘柄の場合のみ<br>追加情報出力フラグ：falseの場合、null
	FiscalYearEndBasic *int32 `json:"FiscalYearEndBasic,omitempty"`

	// KCMarginBuy 一般信用買建フラグ<br>※trueのとき、一般信用(長期)または一般信用(デイトレ)が買建可能<br>※株式銘柄の場合のみ
	KCMarginBuy *bool `json:"KCMarginBuy,omitempty"`

	// KCMarginSell 一般信用売建フラグ<br>※trueのとき、一般信用(長期)または一般信用(デイトレ)が売建可能<br>※株式銘柄の場合のみ
	KCMarginSell *bool `json:"KCMarginSell,omitempty"`

	// LowerLimit 値幅下限<br>※株式・先物・オプション銘柄の場合のみ
	LowerLimit *float64 `json:"LowerLimit,omitempty"`

	// MarginBuy 制度信用買建フラグ<br>※trueのとき制度信用買建可能<br>※株式銘柄の場合のみ
	MarginBuy *bool `json:"MarginBuy,omitempty"`

	// MarginSell 制度信用売建フラグ<br>※trueのとき制度信用売建可能<br>※株式銘柄の場合のみ
	MarginSell *bool `json:"MarginSell,omitempty"`

	// PriceRangeGroup 呼値グループ<br>
	// ※株式・先物・オプション銘柄の場合のみ<br>
	// ※各呼値コードが対応する商品は以下となります。<BR>
	// 　株式の呼値の単位の詳細は [JPXページ](https://www.jpx.co.jp/equities/trading/domestic/07.html) をご覧ください。<BR>
	// 　10000：株式(TOPIX100採用銘柄以外)　<br>
	// 　10003：株式(TOPIX100採用銘柄)<br>
	// 　10118 : 日経平均先物<br>
	// 　10119 : 日経225mini<br>
	// 　10318 : 日経平均オプション<br>
	// 　10706 : ﾐﾆTOPIX先物<br>
	// 　10718 : TOPIX先物<br>
	// 　12122 : JPX日経400指数先物<br>
	// 　14473 : NYダウ先物<br>
	// 　14515 : 日経平均VI先物<br>
	// 　15411 : 東証マザーズ指数先物<br>
	// 　15569 : 東証REIT指数先物<br>
	// 　17163 : TOPIXCore30指数先物<br>
	// <table>
	//   <thead>
	//       <tr>
	//           <th>呼値コード</th>
	//           <th>値段の水準</th>
	//           <th>呼値単位</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>10000</td>
	//           <td>3000円以下</td>
	//           <td>1</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>5000円以下</td>
	//           <td>5</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>30000円以下</td>
	//           <td>10</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>50000円以下</td>
	//           <td>50</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>300000円以下</td>
	//           <td>100</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>500000円以下</td>
	//           <td>500</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>3000000円以下</td>
	//           <td>1000</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>5000000円以下</td>
	//           <td>5000</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>30000000円以下</td>
	//           <td>10000</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>50000000円以下</td>
	//           <td>50000</td>
	//       </tr>
	//       <tr>
	//           <td>10000</td>
	//           <td>50000000円超</td>
	//           <td>100000</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>1000円以下</td>
	//           <td>0.1</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>3000円以下</td>
	//           <td>0.5</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>10000円以下</td>
	//           <td>1</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>30000円以下</td>
	//           <td>5</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>100000円以下</td>
	//           <td>10</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>300000円以下</td>
	//           <td>50</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>1000000円以下</td>
	//           <td>100</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>3000000円以下</td>
	//           <td>500</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>10000000円以下</td>
	//           <td>1000</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>30000000円以下</td>
	//           <td>5000</td>
	//       </tr>
	//       <tr>
	//           <td>10003</td>
	//           <td>30000000円超</td>
	//           <td>10000</td>
	//       </tr>
	//       <tr>
	//           <td>10118</td>
	//           <td>-</td>
	//           <td>10</td>
	//       </tr>
	//       <tr>
	//           <td>10119</td>
	//           <td>-</td>
	//           <td>5</td>
	//       </tr>
	//       <tr>
	//           <td>10318</td>
	//           <td>100円以下</td>
	//           <td>1</td>
	//       </tr>
	//       <tr>
	//           <td>10318</td>
	//           <td>1000円以下</td>
	//           <td>5</td>
	//       </tr>
	//       <tr>
	//           <td>10318</td>
	//           <td>1000円超</td>
	//           <td>10</td>
	//       </tr>
	//       <tr>
	//           <td>10706</td>
	//           <td>-</td>
	//           <td>0.25</td>
	//       </tr>
	//       <tr>
	//           <td>10718</td>
	//           <td>-</td>
	//           <td>0.5</td>
	//       </tr>
	//       <tr>
	//           <td>12122</td>
	//           <td>-</td>
	//           <td>5</td>
	//       </tr>
	//       <tr>
	//           <td>14473</td>
	//           <td>-</td>
	//           <td>1</td>
	//       </tr>
	//       <tr>
	//           <td>14515</td>
	//           <td>-</td>
	//           <td>0.05</td>
	//       </tr>
	//       <tr>
	//           <td>15411</td>
	//           <td>-</td>
	//           <td>1</td>
	//       </tr>
	//       <tr>
	//           <td>15569</td>
	//           <td>-</td>
	//           <td>0.5</td>
	//       </tr>
	//       <tr>
	//           <td>17163</td>
	//           <td>-</td>
	//           <td>0.5</td>
	//       </tr>
	//   </tbody>
	// </table>
	PriceRangeGroup *string `json:"PriceRangeGroup,omitempty"`

	// PutOrCall プット/コール区分<br>※オプション銘柄の場合のみ
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>プット</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>コール</td>
	//       </tr>
	//   </tbody>
	// </table>
	PutOrCall *int32 `json:"PutOrCall,omitempty"`

	// StrikePrice 権利行使価格<br>※オプション銘柄の場合のみ
	StrikePrice *float64 `json:"StrikePrice,omitempty"`

	// Symbol 銘柄コード
	Symbol *string `json:"Symbol,omitempty"`

	// SymbolName 銘柄名
	SymbolName *string `json:"SymbolName,omitempty"`

	// TotalMarketValue 時価総額<br>※株式銘柄の場合のみ<br>追加情報出力フラグ：falseの場合、null
	TotalMarketValue *float64 `json:"TotalMarketValue,omitempty"`

	// TotalStocks 発行済み株式数（千株）<br>※株式銘柄の場合のみ<br>追加情報出力フラグ：falseの場合、null
	TotalStocks *float64 `json:"TotalStocks,omitempty"`

	// TradeEnd 取引終了日<br>※先物・オプション銘柄の場合のみ
	TradeEnd *int32 `json:"TradeEnd,omitempty"`

	// TradeStart 取引開始日<br>※先物・オプション銘柄の場合のみ
	TradeStart *int32 `json:"TradeStart,omitempty"`

	// TradingUnit 売買単位<br>※株式・先物・オプション銘柄の場合のみ
	TradingUnit *float64 `json:"TradingUnit,omitempty"`

	// Underlyer 原資産コード<br>※先物・オプション銘柄の場合のみ
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>NK225</td>
	//           <td>日経225</td>
	//       </tr>
	//       <tr>
	//           <td>NK300</td>
	//           <td>日経300</td>
	//       </tr>
	//       <tr>
	//           <td>MOTHERS</td>
	//           <td>東証マザーズ</td>
	//       </tr>
	//       <tr>
	//           <td>JPX400</td>
	//           <td>JPX日経400</td>
	//       </tr>
	//       <tr>
	//           <td>TOPIX</td>
	//           <td>TOPIX</td>
	//       </tr>
	//       <tr>
	//           <td>NKVI</td>
	//           <td>日経平均VI</td>
	//       </tr>
	//       <tr>
	//           <td>DJIA</td>
	//           <td>NYダウ</td>
	//       </tr>
	//       <tr>
	//           <td>TSEREITINDEX</td>
	//           <td>東証REIT指数</td>
	//       </tr>
	//       <tr>
	//           <td>TOPIXCORE30</td>
	//           <td>TOPIX Core30</td>
	//       </tr>
	//   </tbody>
	// </table>
	Underlyer *string `json:"Underlyer,omitempty"`

	// UpperLimit 値幅上限<br>※株式・先物・オプション銘柄の場合のみ
	UpperLimit *float64 `json:"UpperLimit,omitempty"`
}

// TokenSuccess defines model for TokenSuccess.
type TokenSuccess struct {
	// ResultCode 結果コード<br>0が成功。それ以外はエラーコード。
	ResultCode *int32 `json:"ResultCode,omitempty"`

	// Token APIトークン
	Token *string `json:"Token,omitempty"`
}

// UnregisterAllSuccess defines model for UnregisterAllSuccess.
type UnregisterAllSuccess struct {
	// RegistList 現在登録されている銘柄のリスト<br>※銘柄登録解除が正常に行われれば、空リストを返します。<br>　登録解除でエラー等が発生した場合、現在登録されている銘柄のリストを返します
	RegistList *map[string]interface{} `json:"RegistList,omitempty"`
}

// WalletCashSuccess defines model for WalletCashSuccess.
type WalletCashSuccess struct {
	// StockAccountWallet 現物買付可能額
	StockAccountWallet *float64 `json:"StockAccountWallet,omitempty"`
}

// WalletFutureSuccess defines model for WalletFutureSuccess.
type WalletFutureSuccess struct {
	// FutureTradeLimit 新規建玉可能額
	FutureTradeLimit *float64 `json:"FutureTradeLimit,omitempty"`

	// MarginRequirement 必要証拠金額<br>※銘柄指定の場合のみ。<br>※銘柄が指定されなかった場合、空を返す。
	MarginRequirement *float64 `json:"MarginRequirement,omitempty"`
}

// WalletMarginSuccess defines model for WalletMarginSuccess.
type WalletMarginSuccess struct {
	// CashOfConsignmentDepositRate 現金委託保証金率<br>※銘柄指定の場合のみ。<br>※銘柄が指定されなかった場合、Noneを返す。
	CashOfConsignmentDepositRate *float64 `json:"CashOfConsignmentDepositRate,omitempty"`

	// ConsignmentDepositRate 委託保証金率<br>※銘柄指定の場合のみ。<br>※銘柄が指定されなかった場合、Noneを返す。
	ConsignmentDepositRate *float64 `json:"ConsignmentDepositRate,omitempty"`

	// DepositkeepRate 保証金維持率<br>※銘柄指定の場合のみ<br>※銘柄が指定されなかった場合、0.0を返す。
	DepositkeepRate *float64 `json:"DepositkeepRate,omitempty"`

	// MarginAccountWallet 信用新規可能額
	MarginAccountWallet *float64 `json:"MarginAccountWallet,omitempty"`
}

// WalletOptionSuccess defines model for WalletOptionSuccess.
type WalletOptionSuccess struct {
	// MarginRequirement 必要証拠金額<br>※銘柄指定の場合のみ。<br>※銘柄が指定されなかった場合、空を返す。
	MarginRequirement *float64 `json:"MarginRequirement,omitempty"`

	// OptionBuyTradeLimit 買新規建玉可能額
	OptionBuyTradeLimit *float64 `json:"OptionBuyTradeLimit,omitempty"`

	// OptionSellTradeLimit 売新規建玉可能額
	OptionSellTradeLimit *float64 `json:"OptionSellTradeLimit,omitempty"`
}

// ApisoftlimitGetParams defines parameters for ApisoftlimitGet.
type ApisoftlimitGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// BoardGetParams defines parameters for BoardGet.
type BoardGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// CancelorderPutParams defines parameters for CancelorderPut.
type CancelorderPutParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// ExchangeGetParams defines parameters for ExchangeGet.
type ExchangeGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// ExchangeGetParamsSymbol defines parameters for ExchangeGet.
type ExchangeGetParamsSymbol string

// MarginpremiumGetParams defines parameters for MarginpremiumGet.
type MarginpremiumGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// OrdersGetParams defines parameters for OrdersGet.
type OrdersGetParams struct {
	// Product 取得する商品
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0</td>
	//           <td>すべて </td>
	//       </tr>
	//       <tr>
	//           <td>1</td>
	//           <td>現物</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>信用</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>先物</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>OP</td>
	//       </tr>
	//   </tbody>
	// </table>
	Product *OrdersGetParamsProduct `form:"product,omitempty" json:"product,omitempty"`

	// Id 注文番号<br>
	// ※指定された注文番号と一致する注文のみレスポンスします。<br>
	// ※指定された注文番号との比較では大文字小文字を区別しません。<br>
	// ※複数の注文番号を指定することはできません。
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Updtime 更新日時<br>
	// ※形式：yyyyMMddHHmmss （例：20201201123456）<br>
	// ※指定された更新日時以降（指定日時含む）に更新された注文のみレスポンスします。<br>
	// ※複数の更新日時を指定することはできません。
	Updtime *string `form:"updtime,omitempty" json:"updtime,omitempty"`

	// Details 注文詳細抑止
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>true</td>
	//           <td>注文詳細を出力する（デフォルト）</td>
	//       </tr>
	//       <tr>
	//           <td>false</td>
	//           <td>注文詳細の出力しない</td>
	//       </tr>
	//   </tbody>
	// </table>
	Details *string `form:"details,omitempty" json:"details,omitempty"`

	// Symbol 銘柄コード<br>※指定された銘柄コードと一致する注文のみレスポンスします。<br>※複数の銘柄コードを指定することができません。
	Symbol *string `form:"symbol,omitempty" json:"symbol,omitempty"`

	// State 状態<br>
	// ※指定された状態と一致する注文のみレスポンスします。<br>
	// ※フィルタには数字の入力のみ受け付けます。<br>
	// ※複数の状態を指定することはできません。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>待機（発注待機）</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>処理中（発注送信中）</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>処理済（発注済・訂正済）</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>訂正取消送信中</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>終了（発注エラー・取消済・全約定・失効・期限切れ）</td>
	//       </tr>
	//   </tbody>
	// </table>
	State *OrdersGetParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Side 売買区分<br>
	// ※指定された売買区分と一致する注文のみレスポンスします。<br>
	// ※フィルタには数字の入力のみ受け付けます。<br>
	// ※複数の売買区分を指定することができません。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>売</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>買</td>
	//       </tr>
	//   </tbody>
	// </table>
	Side *OrdersGetParamsSide `form:"side,omitempty" json:"side,omitempty"`

	// Cashmargin 取引区分<br>
	// ※指定された取引区分と一致する注文のみレスポンスします。<br>
	// ※フィルタには数字の入力のみ受け付けます。<br>
	// ※複数の取引区分を指定することができません。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>2</td>
	//           <td>新規</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>返済</td>
	//       </tr>
	//   </tbody>
	// </table>
	Cashmargin *OrdersGetParamsCashmargin `form:"cashmargin,omitempty" json:"cashmargin,omitempty"`

	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// OrdersGetParamsProduct defines parameters for OrdersGet.
type OrdersGetParamsProduct string

// OrdersGetParamsState defines parameters for OrdersGet.
type OrdersGetParamsState string

// OrdersGetParamsSide defines parameters for OrdersGet.
type OrdersGetParamsSide string

// OrdersGetParamsCashmargin defines parameters for OrdersGet.
type OrdersGetParamsCashmargin string

// PositionsGetParams defines parameters for PositionsGet.
type PositionsGetParams struct {
	// Product 取得する商品
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>0</td>
	//           <td>すべて</td>
	//       </tr>
	//       <tr>
	//           <td>1</td>
	//           <td>現物</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>信用</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>先物</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>OP</td>
	//       </tr>
	//   </tbody>
	// </table>
	Product *PositionsGetParamsProduct `form:"product,omitempty" json:"product,omitempty"`

	// Symbol 銘柄コード<br>※指定された銘柄コードと一致するポジションのみレスポンスします。<br>※複数の銘柄コードを指定することはできません。
	Symbol *string `form:"symbol,omitempty" json:"symbol,omitempty"`

	// Side 売買区分フィルタ<br>
	// 指定された売買区分と一致する注文を返す
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>売</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>買</td>
	//       </tr>
	//   </tbody>
	// </table>
	Side *PositionsGetParamsSide `form:"side,omitempty" json:"side,omitempty"`

	// Addinfo 追加情報出力フラグ（未指定時：true）<br>
	// ※追加情報は、「現在値」、「評価金額」、「評価損益額」、「評価損益率」を意味します。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>true</td>
	//           <td>追加情報を出力する</td>
	//       </tr>
	//       <tr>
	//           <td>false</td>
	//           <td>追加情報を出力しない</td>
	//       </tr>
	//   </tbody>
	// </table>
	Addinfo *string `form:"addinfo,omitempty" json:"addinfo,omitempty"`

	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// PositionsGetParamsProduct defines parameters for PositionsGet.
type PositionsGetParamsProduct string

// PositionsGetParamsSide defines parameters for PositionsGet.
type PositionsGetParamsSide string

// PrimaryExchangeGetParams defines parameters for PrimaryExchangeGet.
type PrimaryExchangeGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// RankingGetParams defines parameters for RankingGet.
type RankingGetParams struct {
	// Type 種別<br>
	// ※信用情報ランキングに「福証」「札証」を指定した場合は、空レスポンスになります
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>1</td>
	//           <td>値上がり率（デフォルト）</td>
	//       </tr>
	//       <tr>
	//           <td>2</td>
	//           <td>値下がり率</td>
	//       </tr>
	//       <tr>
	//           <td>3</td>
	//           <td>売買高上位</td>
	//       </tr>
	//       <tr>
	//           <td>4</td>
	//           <td>売買代金</td>
	//       </tr>
	//       <tr>
	//           <td>5</td>
	//           <td>TICK回数</td>
	//       </tr>
	//       <tr>
	//           <td>6</td>
	//           <td>売買高急増</td>
	//       </tr>
	//       <tr>
	//           <td>7</td>
	//           <td>売買代金急増</td>
	//       </tr>
	//       <tr>
	//           <td>8</td>
	//           <td>信用売残増</td>
	//       </tr>
	//       <tr>
	//           <td>9</td>
	//           <td>信用売残減</td>
	//       </tr>
	//       <tr>
	//           <td>10</td>
	//           <td>信用買残増</td>
	//       </tr>
	//       <tr>
	//           <td>11</td>
	//           <td>信用買残減</td>
	//       </tr>
	//       <tr>
	//           <td>12</td>
	//           <td>信用高倍率</td>
	//       </tr>
	//       <tr>
	//           <td>13</td>
	//           <td>信用低倍率</td>
	//       </tr>
	//       <tr>
	//           <td>14</td>
	//           <td>業種別値上がり率</td>
	//       </tr>
	//       <tr>
	//           <td>15</td>
	//           <td>業種別値下がり率</td>
	//       </tr>
	//   </tbody>
	// </table>
	Type RankingGetParamsType `form:"Type" json:"Type"`

	// ExchangeDivision 市場<br>
	// ※業種別値上がり率・値下がり率に市場を指定しても無視されます
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>ALL</td>
	//           <td>全市場（デフォルト）</td>
	//       </tr>
	//       <tr>
	//           <td>T</td>
	//           <td>東証全体</td>
	//       </tr>
	//       <tr>
	//           <td>TP</td>
	//           <td>東証プライム</td>
	//       </tr>
	//       <tr>
	//           <td>TS</td>
	//           <td>東証スタンダード</td>
	//       </tr>
	//       <tr>
	//           <td>TG</td>
	//           <td>東証グロース</td>
	//       </tr>
	//       <tr>
	//           <td>M</td>
	//           <td>名証</td>
	//       </tr>
	//       <tr>
	//           <td>FK</td>
	//           <td>福証</td>
	//       </tr>
	//       <tr>
	//           <td>S</td>
	//           <td>札証</td>
	//       </tr>
	//   </tbody>
	// </table>
	ExchangeDivision RankingGetParamsExchangeDivision `form:"ExchangeDivision" json:"ExchangeDivision"`

	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// RankingGetParamsType defines parameters for RankingGet.
type RankingGetParamsType string

// RankingGetParamsExchangeDivision defines parameters for RankingGet.
type RankingGetParamsExchangeDivision string

// RegisterPutParams defines parameters for RegisterPut.
type RegisterPutParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// RegulationsGetParams defines parameters for RegulationsGet.
type RegulationsGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// SendorderPostParams defines parameters for SendorderPost.
type SendorderPostParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// SendoderFuturePostParams defines parameters for SendoderFuturePost.
type SendoderFuturePostParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// SendorderOptionPostParams defines parameters for SendorderOptionPost.
type SendorderOptionPostParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// SymbolGetParams defines parameters for SymbolGet.
type SymbolGetParams struct {
	// Addinfo 追加情報出力フラグ（未指定時：true）<br>
	// ※追加情報は、「時価総額」、「発行済み株式数」、「決算期日」、「清算値」を意味します。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>true</td>
	//           <td>追加情報を出力する</td>
	//       </tr>
	//       <tr>
	//           <td>false</td>
	//           <td>追加情報を出力しない</td>
	//       </tr>
	//   </tbody>
	// </table>
	Addinfo *string `form:"addinfo,omitempty" json:"addinfo,omitempty"`

	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// SymbolnameFutureGetParams defines parameters for SymbolnameFutureGet.
type SymbolnameFutureGetParams struct {
	// FutureCode 先物コード<br>
	// ※大文字小文字は区別しません。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>NK225</td>
	//           <td>日経平均先物</td>
	//       </tr>
	//       <tr>
	//           <td>NK225mini</td>
	//           <td>日経225mini先物</td>
	//       </tr>
	//       <tr>
	//           <td>TOPIX</td>
	//           <td>TOPIX先物</td>
	//       </tr>
	//       <tr>
	//           <td>TOPIXmini</td>
	//           <td>ミニTOPIX先物</td>
	//       </tr>
	//       <tr>
	//           <td>MOTHERS</td>
	//           <td>東証マザーズ先物</td>
	//       </tr>
	//       <tr>
	//           <td>JPX400</td>
	//           <td>JPX日経400先物</td>
	//       </tr>
	//       <tr>
	//           <td>DOW</td>
	//           <td>NYダウ先物</td>
	//       </tr>
	//       <tr>
	//           <td>VI</td>
	//           <td>日経平均VI先物</td>
	//       </tr>
	//       <tr>
	//           <td>Core30</td>
	//           <td>TOPIX Core30先物</td>
	//       </tr>
	//       <tr>
	//           <td>REIT</td>
	//           <td>東証REIT指数先物</td>
	//       </tr>
	//   </tbody>
	// </table>
	FutureCode *string `form:"FutureCode,omitempty" json:"FutureCode,omitempty"`

	// DerivMonth 限月<br>
	// ※限月はyyyyMM形式で指定します。0を指定した場合、直近限月となります。<br>
	// ※取引最終日に「0」（直近限月）を指定した場合、日中・夜間の時間帯に関わらず、
	// 取引最終日を迎える限月の銘柄コードを返します。取引最終日を迎える銘柄の取引は日中取引をもって終了となりますので、ご注意ください。
	DerivMonth int32 `form:"DerivMonth" json:"DerivMonth"`

	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// SymbolnameOptionGetParams defines parameters for SymbolnameOptionGet.
type SymbolnameOptionGetParams struct {
	// DerivMonth 限月<br>※限月はyyyyMM形式で指定します。0を指定した場合、直近限月となります。<br>※取引最終日に「0」（直近限月）を指定した場合、日中・夜間の時間帯に関わらず、取引最終日を迎える限月の銘柄コードを返します。取引最終日を迎える銘柄の取引は日中取引をもって終了となりますので、ご注意ください。
	DerivMonth int32 `form:"DerivMonth" json:"DerivMonth"`

	// PutOrCall コール or プット<br>
	// ※大文字小文字は区別しません。
	// <table>
	//   <thead>
	//       <tr>
	//           <th>定義値</th>
	//           <th>説明</th>
	//       </tr>
	//   </thead>
	//   <tbody>
	//       <tr>
	//           <td>P</td>
	//           <td>PUT</td>
	//       </tr>
	//       <tr>
	//           <td>C</td>
	//           <td>CALL</td>
	//       </tr>
	//   </tbody>
	// </table>
	PutOrCall string `form:"PutOrCall" json:"PutOrCall"`

	// StrikePrice 権利行使価格<br>※0を指定した場合、APIを実行した時点でのATMとなります。
	StrikePrice int32 `form:"StrikePrice" json:"StrikePrice"`

	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// UnregisterPutParams defines parameters for UnregisterPut.
type UnregisterPutParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// UnregisterAllPutParams defines parameters for UnregisterAllPut.
type UnregisterAllPutParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// WalletCashGetParams defines parameters for WalletCashGet.
type WalletCashGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// GetWalletCashSymbolParams defines parameters for GetWalletCashSymbol.
type GetWalletCashSymbolParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// WalletFutureGetParams defines parameters for WalletFutureGet.
type WalletFutureGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// GetWalletFutureSymbolParams defines parameters for GetWalletFutureSymbol.
type GetWalletFutureSymbolParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// WalletMarginGetParams defines parameters for WalletMarginGet.
type WalletMarginGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// GetWalletMarginSymbolParams defines parameters for GetWalletMarginSymbol.
type GetWalletMarginSymbolParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// WalletOptionGetParams defines parameters for WalletOptionGet.
type WalletOptionGetParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// GetWalletOptionSymbolParams defines parameters for GetWalletOptionSymbol.
type GetWalletOptionSymbolParams struct {
	// XAPIKEY トークン発行メソッドで取得した文字列
	XAPIKEY string `json:"X-API-KEY"`
}

// CancelorderPutJSONRequestBody defines body for CancelorderPut for application/json ContentType.
type CancelorderPutJSONRequestBody = RequestCancelOrder

// RegisterPutJSONRequestBody defines body for RegisterPut for application/json ContentType.
type RegisterPutJSONRequestBody = RequestRegister

// SendorderPostJSONRequestBody defines body for SendorderPost for application/json ContentType.
type SendorderPostJSONRequestBody = RequestSendOrder

// SendoderFuturePostJSONRequestBody defines body for SendoderFuturePost for application/json ContentType.
type SendoderFuturePostJSONRequestBody = RequestSendOrderDerivFuture

// SendorderOptionPostJSONRequestBody defines body for SendorderOptionPost for application/json ContentType.
type SendorderOptionPostJSONRequestBody = RequestSendOrderDerivOption

// TokenPostJSONRequestBody defines body for TokenPost for application/json ContentType.
type TokenPostJSONRequestBody = RequestToken

// UnregisterPutJSONRequestBody defines body for UnregisterPut for application/json ContentType.
type UnregisterPutJSONRequestBody = RequestUnregister

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ApisoftlimitGet request
	ApisoftlimitGet(ctx context.Context, params *ApisoftlimitGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BoardGet request
	BoardGet(ctx context.Context, symbol string, params *BoardGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelorderPut request with any body
	CancelorderPutWithBody(ctx context.Context, params *CancelorderPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelorderPut(ctx context.Context, params *CancelorderPutParams, body CancelorderPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeGet request
	ExchangeGet(ctx context.Context, symbol ExchangeGetParamsSymbol, params *ExchangeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarginpremiumGet request
	MarginpremiumGet(ctx context.Context, symbol string, params *MarginpremiumGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrdersGet request
	OrdersGet(ctx context.Context, params *OrdersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PositionsGet request
	PositionsGet(ctx context.Context, params *PositionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrimaryExchangeGet request
	PrimaryExchangeGet(ctx context.Context, symbol string, params *PrimaryExchangeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RankingGet request
	RankingGet(ctx context.Context, params *RankingGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterPut request with any body
	RegisterPutWithBody(ctx context.Context, params *RegisterPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterPut(ctx context.Context, params *RegisterPutParams, body RegisterPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegulationsGet request
	RegulationsGet(ctx context.Context, symbol string, params *RegulationsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendorderPost request with any body
	SendorderPostWithBody(ctx context.Context, params *SendorderPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendorderPost(ctx context.Context, params *SendorderPostParams, body SendorderPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendoderFuturePost request with any body
	SendoderFuturePostWithBody(ctx context.Context, params *SendoderFuturePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendoderFuturePost(ctx context.Context, params *SendoderFuturePostParams, body SendoderFuturePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendorderOptionPost request with any body
	SendorderOptionPostWithBody(ctx context.Context, params *SendorderOptionPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendorderOptionPost(ctx context.Context, params *SendorderOptionPostParams, body SendorderOptionPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SymbolGet request
	SymbolGet(ctx context.Context, symbol string, params *SymbolGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SymbolnameFutureGet request
	SymbolnameFutureGet(ctx context.Context, params *SymbolnameFutureGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SymbolnameOptionGet request
	SymbolnameOptionGet(ctx context.Context, params *SymbolnameOptionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenPost request with any body
	TokenPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TokenPost(ctx context.Context, body TokenPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnregisterPut request with any body
	UnregisterPutWithBody(ctx context.Context, params *UnregisterPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnregisterPut(ctx context.Context, params *UnregisterPutParams, body UnregisterPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnregisterAllPut request
	UnregisterAllPut(ctx context.Context, params *UnregisterAllPutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WalletCashGet request
	WalletCashGet(ctx context.Context, params *WalletCashGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWalletCashSymbol request
	GetWalletCashSymbol(ctx context.Context, symbol string, params *GetWalletCashSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WalletFutureGet request
	WalletFutureGet(ctx context.Context, params *WalletFutureGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWalletFutureSymbol request
	GetWalletFutureSymbol(ctx context.Context, symbol string, params *GetWalletFutureSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WalletMarginGet request
	WalletMarginGet(ctx context.Context, params *WalletMarginGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWalletMarginSymbol request
	GetWalletMarginSymbol(ctx context.Context, symbol string, params *GetWalletMarginSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WalletOptionGet request
	WalletOptionGet(ctx context.Context, params *WalletOptionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWalletOptionSymbol request
	GetWalletOptionSymbol(ctx context.Context, symbol string, params *GetWalletOptionSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ApisoftlimitGet(ctx context.Context, params *ApisoftlimitGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApisoftlimitGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BoardGet(ctx context.Context, symbol string, params *BoardGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBoardGetRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelorderPutWithBody(ctx context.Context, params *CancelorderPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelorderPutRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelorderPut(ctx context.Context, params *CancelorderPutParams, body CancelorderPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelorderPutRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeGet(ctx context.Context, symbol ExchangeGetParamsSymbol, params *ExchangeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeGetRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarginpremiumGet(ctx context.Context, symbol string, params *MarginpremiumGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarginpremiumGetRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrdersGet(ctx context.Context, params *OrdersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrdersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PositionsGet(ctx context.Context, params *PositionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPositionsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrimaryExchangeGet(ctx context.Context, symbol string, params *PrimaryExchangeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrimaryExchangeGetRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RankingGet(ctx context.Context, params *RankingGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRankingGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterPutWithBody(ctx context.Context, params *RegisterPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterPutRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterPut(ctx context.Context, params *RegisterPutParams, body RegisterPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterPutRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegulationsGet(ctx context.Context, symbol string, params *RegulationsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegulationsGetRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendorderPostWithBody(ctx context.Context, params *SendorderPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendorderPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendorderPost(ctx context.Context, params *SendorderPostParams, body SendorderPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendorderPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendoderFuturePostWithBody(ctx context.Context, params *SendoderFuturePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendoderFuturePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendoderFuturePost(ctx context.Context, params *SendoderFuturePostParams, body SendoderFuturePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendoderFuturePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendorderOptionPostWithBody(ctx context.Context, params *SendorderOptionPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendorderOptionPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendorderOptionPost(ctx context.Context, params *SendorderOptionPostParams, body SendorderOptionPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendorderOptionPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SymbolGet(ctx context.Context, symbol string, params *SymbolGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSymbolGetRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SymbolnameFutureGet(ctx context.Context, params *SymbolnameFutureGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSymbolnameFutureGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SymbolnameOptionGet(ctx context.Context, params *SymbolnameOptionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSymbolnameOptionGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenPost(ctx context.Context, body TokenPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterPutWithBody(ctx context.Context, params *UnregisterPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterPutRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterPut(ctx context.Context, params *UnregisterPutParams, body UnregisterPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterPutRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterAllPut(ctx context.Context, params *UnregisterAllPutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterAllPutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WalletCashGet(ctx context.Context, params *WalletCashGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWalletCashGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWalletCashSymbol(ctx context.Context, symbol string, params *GetWalletCashSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletCashSymbolRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WalletFutureGet(ctx context.Context, params *WalletFutureGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWalletFutureGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWalletFutureSymbol(ctx context.Context, symbol string, params *GetWalletFutureSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletFutureSymbolRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WalletMarginGet(ctx context.Context, params *WalletMarginGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWalletMarginGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWalletMarginSymbol(ctx context.Context, symbol string, params *GetWalletMarginSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletMarginSymbolRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WalletOptionGet(ctx context.Context, params *WalletOptionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWalletOptionGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWalletOptionSymbol(ctx context.Context, symbol string, params *GetWalletOptionSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletOptionSymbolRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewApisoftlimitGetRequest generates requests for ApisoftlimitGet
func NewApisoftlimitGetRequest(server string, params *ApisoftlimitGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apisoftlimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewBoardGetRequest generates requests for BoardGet
func NewBoardGetRequest(server string, symbol string, params *BoardGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/board/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewCancelorderPutRequest calls the generic CancelorderPut builder with application/json body
func NewCancelorderPutRequest(server string, params *CancelorderPutParams, body CancelorderPutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelorderPutRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCancelorderPutRequestWithBody generates requests for CancelorderPut with any type of body
func NewCancelorderPutRequestWithBody(server string, params *CancelorderPutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cancelorder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewExchangeGetRequest generates requests for ExchangeGet
func NewExchangeGetRequest(server string, symbol ExchangeGetParamsSymbol, params *ExchangeGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchange/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewMarginpremiumGetRequest generates requests for MarginpremiumGet
func NewMarginpremiumGetRequest(server string, symbol string, params *MarginpremiumGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/margin/marginpremium/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewOrdersGetRequest generates requests for OrdersGet
func NewOrdersGetRequest(server string, params *OrdersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Updtime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updtime", runtime.ParamLocationQuery, *params.Updtime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Details != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "details", runtime.ParamLocationQuery, *params.Details); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Side != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "side", runtime.ParamLocationQuery, *params.Side); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cashmargin != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cashmargin", runtime.ParamLocationQuery, *params.Cashmargin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewPositionsGetRequest generates requests for PositionsGet
func NewPositionsGetRequest(server string, params *PositionsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/positions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Symbol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Side != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "side", runtime.ParamLocationQuery, *params.Side); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Addinfo != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addinfo", runtime.ParamLocationQuery, *params.Addinfo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewPrimaryExchangeGetRequest generates requests for PrimaryExchangeGet
func NewPrimaryExchangeGetRequest(server string, symbol string, params *PrimaryExchangeGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/primaryexchange/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewRankingGetRequest generates requests for RankingGet
func NewRankingGetRequest(server string, params *RankingGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ranking")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Type", runtime.ParamLocationQuery, params.Type); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ExchangeDivision", runtime.ParamLocationQuery, params.ExchangeDivision); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewRegisterPutRequest calls the generic RegisterPut builder with application/json body
func NewRegisterPutRequest(server string, params *RegisterPutParams, body RegisterPutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterPutRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRegisterPutRequestWithBody generates requests for RegisterPut with any type of body
func NewRegisterPutRequestWithBody(server string, params *RegisterPutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewRegulationsGetRequest generates requests for RegulationsGet
func NewRegulationsGetRequest(server string, symbol string, params *RegulationsGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/regulations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewSendorderPostRequest calls the generic SendorderPost builder with application/json body
func NewSendorderPostRequest(server string, params *SendorderPostParams, body SendorderPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendorderPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendorderPostRequestWithBody generates requests for SendorderPost with any type of body
func NewSendorderPostRequestWithBody(server string, params *SendorderPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendorder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewSendoderFuturePostRequest calls the generic SendoderFuturePost builder with application/json body
func NewSendoderFuturePostRequest(server string, params *SendoderFuturePostParams, body SendoderFuturePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendoderFuturePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendoderFuturePostRequestWithBody generates requests for SendoderFuturePost with any type of body
func NewSendoderFuturePostRequestWithBody(server string, params *SendoderFuturePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendorder/future")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewSendorderOptionPostRequest calls the generic SendorderOptionPost builder with application/json body
func NewSendorderOptionPostRequest(server string, params *SendorderOptionPostParams, body SendorderOptionPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendorderOptionPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendorderOptionPostRequestWithBody generates requests for SendorderOptionPost with any type of body
func NewSendorderOptionPostRequestWithBody(server string, params *SendorderOptionPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sendorder/option")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewSymbolGetRequest generates requests for SymbolGet
func NewSymbolGetRequest(server string, symbol string, params *SymbolGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/symbol/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Addinfo != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addinfo", runtime.ParamLocationQuery, *params.Addinfo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewSymbolnameFutureGetRequest generates requests for SymbolnameFutureGet
func NewSymbolnameFutureGetRequest(server string, params *SymbolnameFutureGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/symbolname/future")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FutureCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "FutureCode", runtime.ParamLocationQuery, *params.FutureCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "DerivMonth", runtime.ParamLocationQuery, params.DerivMonth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewSymbolnameOptionGetRequest generates requests for SymbolnameOptionGet
func NewSymbolnameOptionGetRequest(server string, params *SymbolnameOptionGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/symbolname/option")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "DerivMonth", runtime.ParamLocationQuery, params.DerivMonth); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "PutOrCall", runtime.ParamLocationQuery, params.PutOrCall); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "StrikePrice", runtime.ParamLocationQuery, params.StrikePrice); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewTokenPostRequest calls the generic TokenPost builder with application/json body
func NewTokenPostRequest(server string, body TokenPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTokenPostRequestWithBody(server, "application/json", bodyReader)
}

// NewTokenPostRequestWithBody generates requests for TokenPost with any type of body
func NewTokenPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnregisterPutRequest calls the generic UnregisterPut builder with application/json body
func NewUnregisterPutRequest(server string, params *UnregisterPutParams, body UnregisterPutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnregisterPutRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUnregisterPutRequestWithBody generates requests for UnregisterPut with any type of body
func NewUnregisterPutRequestWithBody(server string, params *UnregisterPutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unregister")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewUnregisterAllPutRequest generates requests for UnregisterAllPut
func NewUnregisterAllPutRequest(server string, params *UnregisterAllPutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/unregister/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewWalletCashGetRequest generates requests for WalletCashGet
func NewWalletCashGetRequest(server string, params *WalletCashGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallet/cash")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewGetWalletCashSymbolRequest generates requests for GetWalletCashSymbol
func NewGetWalletCashSymbolRequest(server string, symbol string, params *GetWalletCashSymbolParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallet/cash/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewWalletFutureGetRequest generates requests for WalletFutureGet
func NewWalletFutureGetRequest(server string, params *WalletFutureGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallet/future")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewGetWalletFutureSymbolRequest generates requests for GetWalletFutureSymbol
func NewGetWalletFutureSymbolRequest(server string, symbol string, params *GetWalletFutureSymbolParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallet/future/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewWalletMarginGetRequest generates requests for WalletMarginGet
func NewWalletMarginGetRequest(server string, params *WalletMarginGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallet/margin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewGetWalletMarginSymbolRequest generates requests for GetWalletMarginSymbol
func NewGetWalletMarginSymbolRequest(server string, symbol string, params *GetWalletMarginSymbolParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallet/margin/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewWalletOptionGetRequest generates requests for WalletOptionGet
func NewWalletOptionGetRequest(server string, params *WalletOptionGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallet/option")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

// NewGetWalletOptionSymbolRequest generates requests for GetWalletOptionSymbol
func NewGetWalletOptionSymbolRequest(server string, symbol string, params *GetWalletOptionSymbolParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallet/option/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-API-KEY", runtime.ParamLocationHeader, params.XAPIKEY)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-API-KEY", headerParam0)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ApisoftlimitGet request
	ApisoftlimitGetWithResponse(ctx context.Context, params *ApisoftlimitGetParams, reqEditors ...RequestEditorFn) (*ApisoftlimitGetResponse, error)

	// BoardGet request
	BoardGetWithResponse(ctx context.Context, symbol string, params *BoardGetParams, reqEditors ...RequestEditorFn) (*BoardGetResponse, error)

	// CancelorderPut request with any body
	CancelorderPutWithBodyWithResponse(ctx context.Context, params *CancelorderPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelorderPutResponse, error)

	CancelorderPutWithResponse(ctx context.Context, params *CancelorderPutParams, body CancelorderPutJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelorderPutResponse, error)

	// ExchangeGet request
	ExchangeGetWithResponse(ctx context.Context, symbol ExchangeGetParamsSymbol, params *ExchangeGetParams, reqEditors ...RequestEditorFn) (*ExchangeGetResponse, error)

	// MarginpremiumGet request
	MarginpremiumGetWithResponse(ctx context.Context, symbol string, params *MarginpremiumGetParams, reqEditors ...RequestEditorFn) (*MarginpremiumGetResponse, error)

	// OrdersGet request
	OrdersGetWithResponse(ctx context.Context, params *OrdersGetParams, reqEditors ...RequestEditorFn) (*OrdersGetResponse, error)

	// PositionsGet request
	PositionsGetWithResponse(ctx context.Context, params *PositionsGetParams, reqEditors ...RequestEditorFn) (*PositionsGetResponse, error)

	// PrimaryExchangeGet request
	PrimaryExchangeGetWithResponse(ctx context.Context, symbol string, params *PrimaryExchangeGetParams, reqEditors ...RequestEditorFn) (*PrimaryExchangeGetResponse, error)

	// RankingGet request
	RankingGetWithResponse(ctx context.Context, params *RankingGetParams, reqEditors ...RequestEditorFn) (*RankingGetResponse, error)

	// RegisterPut request with any body
	RegisterPutWithBodyWithResponse(ctx context.Context, params *RegisterPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterPutResponse, error)

	RegisterPutWithResponse(ctx context.Context, params *RegisterPutParams, body RegisterPutJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterPutResponse, error)

	// RegulationsGet request
	RegulationsGetWithResponse(ctx context.Context, symbol string, params *RegulationsGetParams, reqEditors ...RequestEditorFn) (*RegulationsGetResponse, error)

	// SendorderPost request with any body
	SendorderPostWithBodyWithResponse(ctx context.Context, params *SendorderPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendorderPostResponse, error)

	SendorderPostWithResponse(ctx context.Context, params *SendorderPostParams, body SendorderPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendorderPostResponse, error)

	// SendoderFuturePost request with any body
	SendoderFuturePostWithBodyWithResponse(ctx context.Context, params *SendoderFuturePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendoderFuturePostResponse, error)

	SendoderFuturePostWithResponse(ctx context.Context, params *SendoderFuturePostParams, body SendoderFuturePostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendoderFuturePostResponse, error)

	// SendorderOptionPost request with any body
	SendorderOptionPostWithBodyWithResponse(ctx context.Context, params *SendorderOptionPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendorderOptionPostResponse, error)

	SendorderOptionPostWithResponse(ctx context.Context, params *SendorderOptionPostParams, body SendorderOptionPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendorderOptionPostResponse, error)

	// SymbolGet request
	SymbolGetWithResponse(ctx context.Context, symbol string, params *SymbolGetParams, reqEditors ...RequestEditorFn) (*SymbolGetResponse, error)

	// SymbolnameFutureGet request
	SymbolnameFutureGetWithResponse(ctx context.Context, params *SymbolnameFutureGetParams, reqEditors ...RequestEditorFn) (*SymbolnameFutureGetResponse, error)

	// SymbolnameOptionGet request
	SymbolnameOptionGetWithResponse(ctx context.Context, params *SymbolnameOptionGetParams, reqEditors ...RequestEditorFn) (*SymbolnameOptionGetResponse, error)

	// TokenPost request with any body
	TokenPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenPostResponse, error)

	TokenPostWithResponse(ctx context.Context, body TokenPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TokenPostResponse, error)

	// UnregisterPut request with any body
	UnregisterPutWithBodyWithResponse(ctx context.Context, params *UnregisterPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterPutResponse, error)

	UnregisterPutWithResponse(ctx context.Context, params *UnregisterPutParams, body UnregisterPutJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterPutResponse, error)

	// UnregisterAllPut request
	UnregisterAllPutWithResponse(ctx context.Context, params *UnregisterAllPutParams, reqEditors ...RequestEditorFn) (*UnregisterAllPutResponse, error)

	// WalletCashGet request
	WalletCashGetWithResponse(ctx context.Context, params *WalletCashGetParams, reqEditors ...RequestEditorFn) (*WalletCashGetResponse, error)

	// GetWalletCashSymbol request
	GetWalletCashSymbolWithResponse(ctx context.Context, symbol string, params *GetWalletCashSymbolParams, reqEditors ...RequestEditorFn) (*GetWalletCashSymbolResponse, error)

	// WalletFutureGet request
	WalletFutureGetWithResponse(ctx context.Context, params *WalletFutureGetParams, reqEditors ...RequestEditorFn) (*WalletFutureGetResponse, error)

	// GetWalletFutureSymbol request
	GetWalletFutureSymbolWithResponse(ctx context.Context, symbol string, params *GetWalletFutureSymbolParams, reqEditors ...RequestEditorFn) (*GetWalletFutureSymbolResponse, error)

	// WalletMarginGet request
	WalletMarginGetWithResponse(ctx context.Context, params *WalletMarginGetParams, reqEditors ...RequestEditorFn) (*WalletMarginGetResponse, error)

	// GetWalletMarginSymbol request
	GetWalletMarginSymbolWithResponse(ctx context.Context, symbol string, params *GetWalletMarginSymbolParams, reqEditors ...RequestEditorFn) (*GetWalletMarginSymbolResponse, error)

	// WalletOptionGet request
	WalletOptionGetWithResponse(ctx context.Context, params *WalletOptionGetParams, reqEditors ...RequestEditorFn) (*WalletOptionGetResponse, error)

	// GetWalletOptionSymbol request
	GetWalletOptionSymbolWithResponse(ctx context.Context, symbol string, params *GetWalletOptionSymbolParams, reqEditors ...RequestEditorFn) (*GetWalletOptionSymbolResponse, error)
}

type ApisoftlimitGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiSoftLimitResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ApisoftlimitGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApisoftlimitGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BoardGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BoardSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BoardGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BoardGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelorderPutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CancelorderPutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelorderPutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarginpremiumGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarginPremiumResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MarginpremiumGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarginpremiumGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrdersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrdersSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r OrdersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrdersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PositionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PositionsSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PositionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PositionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrimaryExchangeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrimaryExchangeResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PrimaryExchangeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrimaryExchangeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RankingGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
	JSON405 *ErrorResponse
	JSON413 *ErrorResponse
	JSON415 *ErrorResponse
	JSON429 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RankingGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RankingGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterPutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RegisterPutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterPutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegulationsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegulationsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RegulationsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegulationsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendorderPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendorderPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendorderPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendoderFuturePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendoderFuturePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendoderFuturePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendorderOptionPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SendorderOptionPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendorderOptionPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SymbolGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SymbolSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SymbolGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SymbolGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SymbolnameFutureGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SymbolNameSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SymbolnameFutureGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SymbolnameFutureGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SymbolnameOptionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SymbolNameSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SymbolnameOptionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SymbolnameOptionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TokenPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnregisterPutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UnregisterPutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnregisterPutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnregisterAllPutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnregisterAllSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UnregisterAllPutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnregisterAllPutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WalletCashGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletCashSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WalletCashGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WalletCashGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWalletCashSymbolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletCashSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetWalletCashSymbolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletCashSymbolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WalletFutureGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletFutureSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WalletFutureGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WalletFutureGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWalletFutureSymbolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletFutureSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetWalletFutureSymbolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletFutureSymbolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WalletMarginGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletMarginSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WalletMarginGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WalletMarginGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWalletMarginSymbolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletMarginSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetWalletMarginSymbolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletMarginSymbolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WalletOptionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletOptionSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WalletOptionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WalletOptionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWalletOptionSymbolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletOptionSuccess
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON405      *ErrorResponse
	JSON413      *ErrorResponse
	JSON415      *ErrorResponse
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetWalletOptionSymbolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletOptionSymbolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ApisoftlimitGetWithResponse request returning *ApisoftlimitGetResponse
func (c *ClientWithResponses) ApisoftlimitGetWithResponse(ctx context.Context, params *ApisoftlimitGetParams, reqEditors ...RequestEditorFn) (*ApisoftlimitGetResponse, error) {
	rsp, err := c.ApisoftlimitGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApisoftlimitGetResponse(rsp)
}

// BoardGetWithResponse request returning *BoardGetResponse
func (c *ClientWithResponses) BoardGetWithResponse(ctx context.Context, symbol string, params *BoardGetParams, reqEditors ...RequestEditorFn) (*BoardGetResponse, error) {
	rsp, err := c.BoardGet(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBoardGetResponse(rsp)
}

// CancelorderPutWithBodyWithResponse request with arbitrary body returning *CancelorderPutResponse
func (c *ClientWithResponses) CancelorderPutWithBodyWithResponse(ctx context.Context, params *CancelorderPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelorderPutResponse, error) {
	rsp, err := c.CancelorderPutWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelorderPutResponse(rsp)
}

func (c *ClientWithResponses) CancelorderPutWithResponse(ctx context.Context, params *CancelorderPutParams, body CancelorderPutJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelorderPutResponse, error) {
	rsp, err := c.CancelorderPut(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelorderPutResponse(rsp)
}

// ExchangeGetWithResponse request returning *ExchangeGetResponse
func (c *ClientWithResponses) ExchangeGetWithResponse(ctx context.Context, symbol ExchangeGetParamsSymbol, params *ExchangeGetParams, reqEditors ...RequestEditorFn) (*ExchangeGetResponse, error) {
	rsp, err := c.ExchangeGet(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeGetResponse(rsp)
}

// MarginpremiumGetWithResponse request returning *MarginpremiumGetResponse
func (c *ClientWithResponses) MarginpremiumGetWithResponse(ctx context.Context, symbol string, params *MarginpremiumGetParams, reqEditors ...RequestEditorFn) (*MarginpremiumGetResponse, error) {
	rsp, err := c.MarginpremiumGet(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarginpremiumGetResponse(rsp)
}

// OrdersGetWithResponse request returning *OrdersGetResponse
func (c *ClientWithResponses) OrdersGetWithResponse(ctx context.Context, params *OrdersGetParams, reqEditors ...RequestEditorFn) (*OrdersGetResponse, error) {
	rsp, err := c.OrdersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrdersGetResponse(rsp)
}

// PositionsGetWithResponse request returning *PositionsGetResponse
func (c *ClientWithResponses) PositionsGetWithResponse(ctx context.Context, params *PositionsGetParams, reqEditors ...RequestEditorFn) (*PositionsGetResponse, error) {
	rsp, err := c.PositionsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePositionsGetResponse(rsp)
}

// PrimaryExchangeGetWithResponse request returning *PrimaryExchangeGetResponse
func (c *ClientWithResponses) PrimaryExchangeGetWithResponse(ctx context.Context, symbol string, params *PrimaryExchangeGetParams, reqEditors ...RequestEditorFn) (*PrimaryExchangeGetResponse, error) {
	rsp, err := c.PrimaryExchangeGet(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrimaryExchangeGetResponse(rsp)
}

// RankingGetWithResponse request returning *RankingGetResponse
func (c *ClientWithResponses) RankingGetWithResponse(ctx context.Context, params *RankingGetParams, reqEditors ...RequestEditorFn) (*RankingGetResponse, error) {
	rsp, err := c.RankingGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRankingGetResponse(rsp)
}

// RegisterPutWithBodyWithResponse request with arbitrary body returning *RegisterPutResponse
func (c *ClientWithResponses) RegisterPutWithBodyWithResponse(ctx context.Context, params *RegisterPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterPutResponse, error) {
	rsp, err := c.RegisterPutWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterPutResponse(rsp)
}

func (c *ClientWithResponses) RegisterPutWithResponse(ctx context.Context, params *RegisterPutParams, body RegisterPutJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterPutResponse, error) {
	rsp, err := c.RegisterPut(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterPutResponse(rsp)
}

// RegulationsGetWithResponse request returning *RegulationsGetResponse
func (c *ClientWithResponses) RegulationsGetWithResponse(ctx context.Context, symbol string, params *RegulationsGetParams, reqEditors ...RequestEditorFn) (*RegulationsGetResponse, error) {
	rsp, err := c.RegulationsGet(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegulationsGetResponse(rsp)
}

// SendorderPostWithBodyWithResponse request with arbitrary body returning *SendorderPostResponse
func (c *ClientWithResponses) SendorderPostWithBodyWithResponse(ctx context.Context, params *SendorderPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendorderPostResponse, error) {
	rsp, err := c.SendorderPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendorderPostResponse(rsp)
}

func (c *ClientWithResponses) SendorderPostWithResponse(ctx context.Context, params *SendorderPostParams, body SendorderPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendorderPostResponse, error) {
	rsp, err := c.SendorderPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendorderPostResponse(rsp)
}

// SendoderFuturePostWithBodyWithResponse request with arbitrary body returning *SendoderFuturePostResponse
func (c *ClientWithResponses) SendoderFuturePostWithBodyWithResponse(ctx context.Context, params *SendoderFuturePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendoderFuturePostResponse, error) {
	rsp, err := c.SendoderFuturePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendoderFuturePostResponse(rsp)
}

func (c *ClientWithResponses) SendoderFuturePostWithResponse(ctx context.Context, params *SendoderFuturePostParams, body SendoderFuturePostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendoderFuturePostResponse, error) {
	rsp, err := c.SendoderFuturePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendoderFuturePostResponse(rsp)
}

// SendorderOptionPostWithBodyWithResponse request with arbitrary body returning *SendorderOptionPostResponse
func (c *ClientWithResponses) SendorderOptionPostWithBodyWithResponse(ctx context.Context, params *SendorderOptionPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendorderOptionPostResponse, error) {
	rsp, err := c.SendorderOptionPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendorderOptionPostResponse(rsp)
}

func (c *ClientWithResponses) SendorderOptionPostWithResponse(ctx context.Context, params *SendorderOptionPostParams, body SendorderOptionPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendorderOptionPostResponse, error) {
	rsp, err := c.SendorderOptionPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendorderOptionPostResponse(rsp)
}

// SymbolGetWithResponse request returning *SymbolGetResponse
func (c *ClientWithResponses) SymbolGetWithResponse(ctx context.Context, symbol string, params *SymbolGetParams, reqEditors ...RequestEditorFn) (*SymbolGetResponse, error) {
	rsp, err := c.SymbolGet(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSymbolGetResponse(rsp)
}

// SymbolnameFutureGetWithResponse request returning *SymbolnameFutureGetResponse
func (c *ClientWithResponses) SymbolnameFutureGetWithResponse(ctx context.Context, params *SymbolnameFutureGetParams, reqEditors ...RequestEditorFn) (*SymbolnameFutureGetResponse, error) {
	rsp, err := c.SymbolnameFutureGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSymbolnameFutureGetResponse(rsp)
}

// SymbolnameOptionGetWithResponse request returning *SymbolnameOptionGetResponse
func (c *ClientWithResponses) SymbolnameOptionGetWithResponse(ctx context.Context, params *SymbolnameOptionGetParams, reqEditors ...RequestEditorFn) (*SymbolnameOptionGetResponse, error) {
	rsp, err := c.SymbolnameOptionGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSymbolnameOptionGetResponse(rsp)
}

// TokenPostWithBodyWithResponse request with arbitrary body returning *TokenPostResponse
func (c *ClientWithResponses) TokenPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenPostResponse, error) {
	rsp, err := c.TokenPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenPostResponse(rsp)
}

func (c *ClientWithResponses) TokenPostWithResponse(ctx context.Context, body TokenPostJSONRequestBody, reqEditors ...RequestEditorFn) (*TokenPostResponse, error) {
	rsp, err := c.TokenPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenPostResponse(rsp)
}

// UnregisterPutWithBodyWithResponse request with arbitrary body returning *UnregisterPutResponse
func (c *ClientWithResponses) UnregisterPutWithBodyWithResponse(ctx context.Context, params *UnregisterPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterPutResponse, error) {
	rsp, err := c.UnregisterPutWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterPutResponse(rsp)
}

func (c *ClientWithResponses) UnregisterPutWithResponse(ctx context.Context, params *UnregisterPutParams, body UnregisterPutJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterPutResponse, error) {
	rsp, err := c.UnregisterPut(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterPutResponse(rsp)
}

// UnregisterAllPutWithResponse request returning *UnregisterAllPutResponse
func (c *ClientWithResponses) UnregisterAllPutWithResponse(ctx context.Context, params *UnregisterAllPutParams, reqEditors ...RequestEditorFn) (*UnregisterAllPutResponse, error) {
	rsp, err := c.UnregisterAllPut(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterAllPutResponse(rsp)
}

// WalletCashGetWithResponse request returning *WalletCashGetResponse
func (c *ClientWithResponses) WalletCashGetWithResponse(ctx context.Context, params *WalletCashGetParams, reqEditors ...RequestEditorFn) (*WalletCashGetResponse, error) {
	rsp, err := c.WalletCashGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWalletCashGetResponse(rsp)
}

// GetWalletCashSymbolWithResponse request returning *GetWalletCashSymbolResponse
func (c *ClientWithResponses) GetWalletCashSymbolWithResponse(ctx context.Context, symbol string, params *GetWalletCashSymbolParams, reqEditors ...RequestEditorFn) (*GetWalletCashSymbolResponse, error) {
	rsp, err := c.GetWalletCashSymbol(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletCashSymbolResponse(rsp)
}

// WalletFutureGetWithResponse request returning *WalletFutureGetResponse
func (c *ClientWithResponses) WalletFutureGetWithResponse(ctx context.Context, params *WalletFutureGetParams, reqEditors ...RequestEditorFn) (*WalletFutureGetResponse, error) {
	rsp, err := c.WalletFutureGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWalletFutureGetResponse(rsp)
}

// GetWalletFutureSymbolWithResponse request returning *GetWalletFutureSymbolResponse
func (c *ClientWithResponses) GetWalletFutureSymbolWithResponse(ctx context.Context, symbol string, params *GetWalletFutureSymbolParams, reqEditors ...RequestEditorFn) (*GetWalletFutureSymbolResponse, error) {
	rsp, err := c.GetWalletFutureSymbol(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletFutureSymbolResponse(rsp)
}

// WalletMarginGetWithResponse request returning *WalletMarginGetResponse
func (c *ClientWithResponses) WalletMarginGetWithResponse(ctx context.Context, params *WalletMarginGetParams, reqEditors ...RequestEditorFn) (*WalletMarginGetResponse, error) {
	rsp, err := c.WalletMarginGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWalletMarginGetResponse(rsp)
}

// GetWalletMarginSymbolWithResponse request returning *GetWalletMarginSymbolResponse
func (c *ClientWithResponses) GetWalletMarginSymbolWithResponse(ctx context.Context, symbol string, params *GetWalletMarginSymbolParams, reqEditors ...RequestEditorFn) (*GetWalletMarginSymbolResponse, error) {
	rsp, err := c.GetWalletMarginSymbol(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletMarginSymbolResponse(rsp)
}

// WalletOptionGetWithResponse request returning *WalletOptionGetResponse
func (c *ClientWithResponses) WalletOptionGetWithResponse(ctx context.Context, params *WalletOptionGetParams, reqEditors ...RequestEditorFn) (*WalletOptionGetResponse, error) {
	rsp, err := c.WalletOptionGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWalletOptionGetResponse(rsp)
}

// GetWalletOptionSymbolWithResponse request returning *GetWalletOptionSymbolResponse
func (c *ClientWithResponses) GetWalletOptionSymbolWithResponse(ctx context.Context, symbol string, params *GetWalletOptionSymbolParams, reqEditors ...RequestEditorFn) (*GetWalletOptionSymbolResponse, error) {
	rsp, err := c.GetWalletOptionSymbol(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletOptionSymbolResponse(rsp)
}

// ParseApisoftlimitGetResponse parses an HTTP response from a ApisoftlimitGetWithResponse call
func ParseApisoftlimitGetResponse(rsp *http.Response) (*ApisoftlimitGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApisoftlimitGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiSoftLimitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBoardGetResponse parses an HTTP response from a BoardGetWithResponse call
func ParseBoardGetResponse(rsp *http.Response) (*BoardGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BoardGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BoardSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCancelorderPutResponse parses an HTTP response from a CancelorderPutWithResponse call
func ParseCancelorderPutResponse(rsp *http.Response) (*CancelorderPutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelorderPutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangeGetResponse parses an HTTP response from a ExchangeGetWithResponse call
func ParseExchangeGetResponse(rsp *http.Response) (*ExchangeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMarginpremiumGetResponse parses an HTTP response from a MarginpremiumGetWithResponse call
func ParseMarginpremiumGetResponse(rsp *http.Response) (*MarginpremiumGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarginpremiumGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarginPremiumResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOrdersGetResponse parses an HTTP response from a OrdersGetWithResponse call
func ParseOrdersGetResponse(rsp *http.Response) (*OrdersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrdersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrdersSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePositionsGetResponse parses an HTTP response from a PositionsGetWithResponse call
func ParsePositionsGetResponse(rsp *http.Response) (*PositionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PositionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PositionsSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePrimaryExchangeGetResponse parses an HTTP response from a PrimaryExchangeGetWithResponse call
func ParsePrimaryExchangeGetResponse(rsp *http.Response) (*PrimaryExchangeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrimaryExchangeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrimaryExchangeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRankingGetResponse parses an HTTP response from a RankingGetWithResponse call
func ParseRankingGetResponse(rsp *http.Response) (*RankingGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RankingGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRegisterPutResponse parses an HTTP response from a RegisterPutWithResponse call
func ParseRegisterPutResponse(rsp *http.Response) (*RegisterPutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterPutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRegulationsGetResponse parses an HTTP response from a RegulationsGetWithResponse call
func ParseRegulationsGetResponse(rsp *http.Response) (*RegulationsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegulationsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegulationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendorderPostResponse parses an HTTP response from a SendorderPostWithResponse call
func ParseSendorderPostResponse(rsp *http.Response) (*SendorderPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendorderPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendoderFuturePostResponse parses an HTTP response from a SendoderFuturePostWithResponse call
func ParseSendoderFuturePostResponse(rsp *http.Response) (*SendoderFuturePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendoderFuturePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendorderOptionPostResponse parses an HTTP response from a SendorderOptionPostWithResponse call
func ParseSendorderOptionPostResponse(rsp *http.Response) (*SendorderOptionPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendorderOptionPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSymbolGetResponse parses an HTTP response from a SymbolGetWithResponse call
func ParseSymbolGetResponse(rsp *http.Response) (*SymbolGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SymbolGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SymbolSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSymbolnameFutureGetResponse parses an HTTP response from a SymbolnameFutureGetWithResponse call
func ParseSymbolnameFutureGetResponse(rsp *http.Response) (*SymbolnameFutureGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SymbolnameFutureGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SymbolNameSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSymbolnameOptionGetResponse parses an HTTP response from a SymbolnameOptionGetWithResponse call
func ParseSymbolnameOptionGetResponse(rsp *http.Response) (*SymbolnameOptionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SymbolnameOptionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SymbolNameSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTokenPostResponse parses an HTTP response from a TokenPostWithResponse call
func ParseTokenPostResponse(rsp *http.Response) (*TokenPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUnregisterPutResponse parses an HTTP response from a UnregisterPutWithResponse call
func ParseUnregisterPutResponse(rsp *http.Response) (*UnregisterPutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnregisterPutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUnregisterAllPutResponse parses an HTTP response from a UnregisterAllPutWithResponse call
func ParseUnregisterAllPutResponse(rsp *http.Response) (*UnregisterAllPutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnregisterAllPutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnregisterAllSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWalletCashGetResponse parses an HTTP response from a WalletCashGetWithResponse call
func ParseWalletCashGetResponse(rsp *http.Response) (*WalletCashGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WalletCashGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletCashSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWalletCashSymbolResponse parses an HTTP response from a GetWalletCashSymbolWithResponse call
func ParseGetWalletCashSymbolResponse(rsp *http.Response) (*GetWalletCashSymbolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWalletCashSymbolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletCashSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWalletFutureGetResponse parses an HTTP response from a WalletFutureGetWithResponse call
func ParseWalletFutureGetResponse(rsp *http.Response) (*WalletFutureGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WalletFutureGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletFutureSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWalletFutureSymbolResponse parses an HTTP response from a GetWalletFutureSymbolWithResponse call
func ParseGetWalletFutureSymbolResponse(rsp *http.Response) (*GetWalletFutureSymbolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWalletFutureSymbolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletFutureSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWalletMarginGetResponse parses an HTTP response from a WalletMarginGetWithResponse call
func ParseWalletMarginGetResponse(rsp *http.Response) (*WalletMarginGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WalletMarginGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletMarginSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWalletMarginSymbolResponse parses an HTTP response from a GetWalletMarginSymbolWithResponse call
func ParseGetWalletMarginSymbolResponse(rsp *http.Response) (*GetWalletMarginSymbolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWalletMarginSymbolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletMarginSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWalletOptionGetResponse parses an HTTP response from a WalletOptionGetWithResponse call
func ParseWalletOptionGetResponse(rsp *http.Response) (*WalletOptionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WalletOptionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletOptionSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWalletOptionSymbolResponse parses an HTTP response from a GetWalletOptionSymbolWithResponse call
func ParseGetWalletOptionSymbolResponse(rsp *http.Response) (*GetWalletOptionSymbolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWalletOptionSymbolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletOptionSuccess
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"LaUDAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
